---
import Navigation from '../components/Navigation.astro';
import Warning from '../components/Warning.astro';

export interface Props {
  title: string;
  description?: string;
  mode: 'rankings' | 'comparison';
  // For comparison mode
  class?: string;
  spec?: string;
  comparisonType?: 'race' | 'trinket' | 'both';
}

const { title, description, mode, class: fixedClass, spec: fixedSpec, comparisonType = 'both' } = Astro.props;
const isRankingsMode = mode === 'rankings';
const isFixedClassSpec = fixedClass && fixedSpec;
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <title>{title} - WoW MoP Rankings</title>
    <link rel="stylesheet" href="/src/styles/global.css" />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: var(--bg-primary);
        color: var(--text-primary);
      }
      
      .page-header {
        text-align: center;
        padding: 30px 20px;
        background-color: var(--bg-secondary);
        border-bottom: 1px solid var(--border-color);
      }
      
      .page-title {
        color: var(--highlight-color);
        margin: 0 0 10px 0;
        font-size: 2.5em;
        font-weight: 700;
      }
      
      .page-description {
        color: var(--text-secondary);
        font-size: 1.1em;
        margin: 0;
      }

      .rankings-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }
      
      .controls {
        margin-bottom: 30px;
        padding: 20px;
        background-color: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }
      
      .controls-title {
        color: var(--highlight-color);
        margin: 0 0 15px 0;
        font-size: 1.2em;
        font-weight: 600;
      }
      
      .controls-grid {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
      }
      
      .control-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      
      .control-group label {
        font-size: 0.9em;
        color: var(--text-muted);
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .control-group select {
        padding: 8px 12px;
        background-color: #2a2a2a;
        border: 1px solid #555;
        border-radius: 4px;
        color: var(--text-primary);
        font-size: 0.9em;
        min-width: 120px;
      }
      
      .control-group select:focus {
        outline: none;
        border-color: var(--highlight-color);
      }
      
      .loading, .error {
        text-align: center;
        padding: 20px;
        margin: 20px 0;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #2a2a2a;
        border-radius: 8px;
        z-index: 1000;
        min-width: 200px;
      }
      
      .loading {
        color: var(--text-muted);
        border: 1px solid var(--border-color);
      }
      
      .error {
        color: var(--highlight-color);
        background-color: #3a2a2a;
        border: 1px solid var(--highlight-color);
      }
      
      #metadata-container {
        min-height: 120px;
        transition: opacity 0.2s ease;
      }
      
      #chart-container {
        min-height: 400px;
        transition: opacity 0.2s ease;
      }
      
      .hidden {
        display: none;
      }
    </style>
    <style is:global>
      .simulation-metadata {
        background-color: var(--bg-secondary);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 30px;
        border: 1px solid var(--border-color);
      }
      
      .metadata-title {
        color: var(--highlight-color);
        margin: 0 0 15px 0;
        font-size: 1.2em;
        font-weight: 600;
      }
      
      .metadata-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }
      
      .metadata-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .metadata-item-wide {
        grid-column: 1 / -1;
      }
      
      .metadata-label {
        font-size: 0.85em;
        color: var(--text-muted);
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .metadata-value {
        font-size: 1em;
        color: var(--text-primary);
        font-weight: 600;
      }
      
      .metadata-value-wrap {
        white-space: normal;
        word-wrap: break-word;
        line-height: 1.4;
      }

      .chart-container {
        background-color: var(--bg-secondary);
        border-radius: 8px;
        padding: 20px;
        border: 1px solid var(--border-color);
      }
      
      .chart-title {
        color: var(--highlight-color);
        margin: 0 0 20px 0;
        font-size: 1.4em;
        font-weight: 600;
      }
      
      .chart-bars {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .chart-item {
        display: grid;
        grid-template-columns: 180px 1fr;
        align-items: center;
        gap: 15px;
        padding: 8px 0;
      }
      
      .chart-labels {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 120px;
        max-width: 180px;
        flex-shrink: 0;
        overflow: hidden;
      }
      
      .chart-rank {
        font-size: 0.9em;
        color: var(--text-muted);
        font-weight: 600;
        min-width: 30px;
      }
      
      .chart-label {
        font-weight: 600;
        color: var(--text-primary);
        text-transform: capitalize;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
      }
      
      .chart-bar-container {
        display: flex;
        align-items: center;
        flex: 1;
        gap: 10px;
        min-width: 0;
      }
      
      .chart-bar-track {
        flex: 1;
        height: 20px;
        background-color: rgba(255,255,255,0.1);
        border-radius: 3px;
        position: relative;
        min-width: 0;
      }
      
      .chart-bar {
        height: 100%;
        border-radius: 3px;
        min-width: 2px;
        transition: width 0.3s ease;
        position: relative;
      }
      
      .chart-value {
        font-weight: 600;
        color: var(--text-primary);
        font-size: 0.9em;
        width: 70px;
        text-align: right;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <Navigation />
    <div class="page-header">
      <h1 class="page-title">{title}</h1>
      {description && <p class="page-description">{description}</p>}
    </div>
    
    <div class="rankings-container">
      <Warning title={isRankingsMode ? "DPS Rankings" : (isFixedClassSpec ? "Race Comparison Results" : "Comparison Results")}>
        {isRankingsMode ? (
          <p>These rankings show <strong>DPS performance</strong> across all specializations using static simulation results with identical encounter conditions and optimal rotations.</p>
        ) : isFixedClassSpec ? (
          <p>These rankings compare <strong>race performance</strong> for {fixedClass} {fixedSpec} using static simulation results. Results show performance differences between races using identical gear and configurations.</p>
        ) : (
          <p>Compare <strong>race performance</strong> across different specs and classes using static simulation results. Select a class and specialization to view performance differences.</p>
        )}
        <p>For live, interactive simulations visit <a href="https://wowsims.com/mop" target="_blank" rel="noopener noreferrer">wowsims.com/mop</a>.</p>
      </Warning>
      
      <div id="metadata-container"></div>
      
      <div class="controls">
        <h3 class="controls-title">
          {isRankingsMode ? "Simulation Options" : (isFixedClassSpec ? "Simulation Options" : "Comparison Options")}
        </h3>
        <div class="controls-grid">
          {!isRankingsMode && comparisonType === 'both' && !isFixedClassSpec && (
            <div class="control-group">
              <label for="comparisonType">Compare:</label>
              <select id="comparisonType">
                <option value="race">Races</option>
                <option value="trinket" disabled>Trinkets (Coming Soon)</option>
              </select>
            </div>
          )}
          
          {!isRankingsMode && !isFixedClassSpec && (
            <>
              <div class="control-group">
                <label for="class">Class:</label>
                <select id="class">
                  <option value="">Select Class</option>
                  <option value="death_knight">Death Knight</option>
                  <option value="druid">Druid</option>
                  <option value="hunter">Hunter</option>
                  <option value="mage">Mage</option>
                  <option value="monk">Monk</option>
                  <option value="paladin">Paladin</option>
                  <option value="priest">Priest</option>
                  <option value="rogue">Rogue</option>
                  <option value="shaman">Shaman</option>
                  <option value="warlock">Warlock</option>
                  <option value="warrior">Warrior</option>
                </select>
              </div>
              
              <div class="control-group">
                <label for="spec">Specialization:</label>
                <select id="spec" disabled>
                  <option value="">Select Class First</option>
                </select>
              </div>
            </>
          )}
          
          <div class="control-group">
            <label for="targetCount">Target Count:</label>
            <select id="targetCount">
              <option value="single">Single Target</option>
              <option value="three">3 Targets</option>
              <option value="cleave">Cleave (2)</option>
              <option value="ten">10 Targets</option>
            </select>
          </div>
          
          <div class="control-group">
            <label for="encounterType">Encounter:</label>
            <select id="encounterType">
              <option value="raid">Raid</option>
            </select>
          </div>
          
          <div class="control-group">
            <label for="duration">Duration:</label>
            <select id="duration">
              <option value="long">Long (5 min)</option>
              <option value="short">Short (2 min)</option>
              <option value="burst">Burst (30s)</option>
            </select>
          </div>
          
          <div class="control-group">
            <label for="phase">Phase:</label>
            <select id="phase">
              <option value="p1">Phase 1</option>
            </select>
          </div>
          
          <div class="control-group">
            <label for="sortBy">Sort By:</label>
            <select id="sortBy">
              <option value="dps">Average DPS</option>
              <option value="max">Max DPS</option>
              <option value="min">Min DPS</option>
              <option value="stdev">Consistency (Low StdDev)</option>
            </select>
          </div>
        </div>
      </div>

      <div id="loading" class="loading hidden">
        {isRankingsMode ? "Loading rankings data..." : "Loading comparison data..."}
      </div>
      <div id="error" class="error hidden"></div>
      
      <div id="chart-container"></div>
    </div>

    <script is:inline type="text/javascript" define:vars={{ mode, fixedClass, fixedSpec, comparisonType }}>
console.log('Unified chart script loaded with:', { mode, fixedClass, fixedSpec, comparisonType });

// Shared utility functions
const formatDuration = (seconds) => {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return minutes > 0 ? `${minutes}m ${remainingSeconds}s` : `${remainingSeconds}s`;
};

const formatRaidBuffs = (buffs) => {
  const activeBuffs = Object.entries(buffs)
    .filter(([_, value]) => value !== false && value !== 0)
    .map(([key, value]) => {
      const readable = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
      return typeof value === 'number' && value > 1 ? `${readable} (${value})` : readable;
    });
  return activeBuffs.join(', ');
};

const formatSimulationDate = (timestamp) => {
  return new Date(timestamp).toLocaleString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    timeZoneName: 'short'
  });
};

// Class specs for comparison mode
const classSpecs = {
  death_knight: [
    { value: 'frost', label: 'Frost' },
    { value: 'unholy', label: 'Unholy' }
  ],
  druid: [
    { value: 'balance', label: 'Balance' },
    { value: 'feral', label: 'Feral' }
  ],
  hunter: [
    { value: 'beast_mastery', label: 'Beast Mastery' },
    { value: 'marksmanship', label: 'Marksmanship' },
    { value: 'survival', label: 'Survival' }
  ],
  mage: [
    { value: 'arcane', label: 'Arcane' },
    { value: 'fire', label: 'Fire' },
    { value: 'frost', label: 'Frost' }
  ],
  monk: [
    { value: 'windwalker', label: 'Windwalker' }
  ],
  paladin: [
    { value: 'retribution', label: 'Retribution' }
  ],
  priest: [
    { value: 'shadow', label: 'Shadow' }
  ],
  rogue: [
    { value: 'assassination', label: 'Assassination' },
    { value: 'combat', label: 'Combat' },
    { value: 'subtlety', label: 'Subtlety' }
  ],
  shaman: [
    { value: 'elemental', label: 'Elemental' },
    { value: 'enhancement', label: 'Enhancement' }
  ],
  warlock: [
    { value: 'affliction', label: 'Affliction' },
    { value: 'demonology', label: 'Demonology' },
    { value: 'destruction', label: 'Destruction' }
  ],
  warrior: [
    { value: 'arms', label: 'Arms' },
    { value: 'fury', label: 'Fury' }
  ]
};

// Class colors for rankings mode
const classColors = {
  death_knight: '#C41E3A',
  druid: '#FF7C0A',
  hunter: '#AAD372',
  mage: '#3FC7EB',
  monk: '#00FF98',
  paladin: '#F48CBA',
  priest: '#FFFFFF',
  rogue: '#FFF468',
  shaman: '#0070DD',
  warlock: '#8788EE',
  warrior: '#C69B6D'
};

// Race colors for comparison mode
const raceColors = {
  human: '#3FC7EB',
  orc: '#C41E3A', 
  dwarf: '#FF7C0A',
  night_elf: '#A330C9',
  undead: '#00FF98',
  tauren: '#8788EE',
  gnome: '#F48CBA',
  troll: '#FFF468',
  blood_elf: '#0070DD',
  draenei: '#C69B6D',
  goblin: '#AAD372',
  worgen: '#FFFFFF',
  pandaren: '#00FF98',
  alliance_pandaren: '#00FF98'
};

class UnifiedChart {
  constructor() {
    this.currentData = null;
    this.isRankingsMode = mode === 'rankings';
    this.isFixedClassSpec = fixedClass && fixedSpec;
    
    this.initializeControls();
    this.bindEvents();
    this.loadInitialData();
  }

  initializeControls() {
    if (this.isRankingsMode) {
      // Rankings mode - no special initialization needed
      console.log('Rankings mode initialized');
    } else if (this.isFixedClassSpec) {
      // Fixed class/spec comparison mode
      console.log('Fixed class/spec mode:', fixedClass, fixedSpec);
    } else {
      // Dynamic comparison mode - set up spec options
      this.updateSpecOptions();
    }

    // Set comparison type if fixed
    if (!this.isRankingsMode && comparisonType !== 'both') {
      const comparisonSelect = document.getElementById('comparisonType');
      if (comparisonSelect) {
        comparisonSelect.value = comparisonType;
      }
    }
  }

  bindEvents() {
    if (!this.isRankingsMode && !this.isFixedClassSpec) {
      // Class change updates spec options (comparison mode only)
      const classSelect = document.getElementById('class');
      if (classSelect) {
        classSelect.addEventListener('change', () => {
          this.updateSpecOptions();
          this.clearData();
        });
      }

      // Data loading triggers for dynamic comparison controls
      const dataSelects = document.querySelectorAll('#spec, #comparisonType');
      dataSelects.forEach(select => {
        select.addEventListener('change', () => this.loadData());
      });
    }
    
    // Common controls that trigger data loading
    const commonSelects = document.querySelectorAll('#targetCount, #encounterType, #duration, #phase');
    commonSelects.forEach(select => {
      select.addEventListener('change', () => this.loadData());
    });
    
    // Sort by only re-renders chart
    const sortBySelect = document.getElementById('sortBy');
    if (sortBySelect) {
      sortBySelect.addEventListener('change', () => this.renderChart());
    }
  }

  updateSpecOptions() {
    if (this.isRankingsMode || this.isFixedClassSpec) return;
    
    const classSelect = document.getElementById('class');
    const specSelect = document.getElementById('spec');
    
    if (!classSelect || !specSelect) return;
    
    const selectedClass = classSelect.value;
    
    // Clear existing options
    specSelect.innerHTML = '<option value="">Select Specialization</option>';
    
    if (selectedClass && classSpecs[selectedClass]) {
      specSelect.disabled = false;
      classSpecs[selectedClass].forEach(spec => {
        const option = document.createElement('option');
        option.value = spec.value;
        option.textContent = spec.label;
        specSelect.appendChild(option);
      });
    } else {
      specSelect.disabled = true;
    }
  }

  getCurrentClass() {
    if (this.isFixedClassSpec) return fixedClass;
    if (this.isRankingsMode) return null;
    const classSelect = document.getElementById('class');
    return classSelect ? classSelect.value : '';
  }

  getCurrentSpec() {
    if (this.isFixedClassSpec) return fixedSpec;
    if (this.isRankingsMode) return null;
    const specSelect = document.getElementById('spec');
    return specSelect ? specSelect.value : '';
  }

  getCurrentComparisonType() {
    if (this.isRankingsMode) return null;
    if (comparisonType !== 'both') return comparisonType;
    const comparisonSelect = document.getElementById('comparisonType');
    return comparisonSelect ? comparisonSelect.value : 'race';
  }

  getFileName() {
    const targetCount = document.getElementById('targetCount').value;
    const encounterType = document.getElementById('encounterType').value;
    const duration = document.getElementById('duration').value;
    const phase = document.getElementById('phase').value;
    
    if (this.isRankingsMode) {
      // Rankings filename: dps_phase_encountertype_targetcount_duration.json
      return `dps_${phase}_${encounterType}_${targetCount}_${duration}.json`;
    } else {
      // Comparison filename: class_spec_comparisontype_phase_encountertype_targetcount_duration.json
      const currentClass = this.getCurrentClass();
      const currentSpec = this.getCurrentSpec();
      const currentComparisonType = this.getCurrentComparisonType();
      return `${currentClass}_${currentSpec}_${currentComparisonType}_${phase}_${encounterType}_${targetCount}_${duration}.json`;
    }
  }

  getDataPath() {
    if (this.isRankingsMode) {
      return `/data/rankings/`;
    } else {
      const currentClass = this.getCurrentClass();
      const currentSpec = this.getCurrentSpec();
      return `/data/comparison/${currentClass}/${currentSpec}/`;
    }
  }

  async loadInitialData() {
    if (this.isRankingsMode || this.isFixedClassSpec) {
      // For rankings mode or fixed class/spec, load immediately
      await this.loadData();
    }
    // For dynamic comparison mode, wait for user to select class/spec
  }

  async loadData() {
    if (!this.isRankingsMode) {
      const currentClass = this.getCurrentClass();
      const currentSpec = this.getCurrentSpec();
      
      if (!currentClass || !currentSpec) {
        console.log('Class or spec not selected');
        return;
      }
    }

    const loadingEl = document.getElementById('loading');
    const errorEl = document.getElementById('error');
    const metadataContainer = document.getElementById('metadata-container');
    const chartContainer = document.getElementById('chart-container');

    if (!loadingEl || !errorEl || !metadataContainer || !chartContainer) {
      console.error('Required elements not found');
      return;
    }

    const scrollY = window.scrollY;

    metadataContainer.style.opacity = '0.5';
    chartContainer.style.opacity = '0.5';
    loadingEl.classList.remove('hidden');
    errorEl.classList.add('hidden');

    try {
      const fileName = this.getFileName();
      const dataPath = this.getDataPath();
      const fullPath = `${dataPath}${fileName}`;
      
      console.log('Loading:', fullPath);
      const response = await fetch(fullPath);
      
      if (!response.ok) {
        throw new Error(`Failed to load ${fileName}: ${response.statusText}`);
      }

      this.currentData = await response.json();
      console.log('Data loaded successfully');
      
      loadingEl.classList.add('hidden');
      
      this.renderMetadata();
      this.renderChart();
      
      metadataContainer.style.opacity = '1';
      chartContainer.style.opacity = '1';
      
      requestAnimationFrame(() => {
        window.scrollTo(0, scrollY);
      });
      
    } catch (error) {
      console.error('Error loading data:', error);
      loadingEl.classList.add('hidden');
      errorEl.textContent = `Error loading data: ${error.message}`;
      errorEl.classList.remove('hidden');
      
      metadataContainer.innerHTML = '';
      chartContainer.innerHTML = '';
      metadataContainer.style.opacity = '1';
      chartContainer.style.opacity = '1';
    }
  }

  clearData() {
    this.currentData = null;
    const metadataContainer = document.getElementById('metadata-container');
    const chartContainer = document.getElementById('chart-container');
    if (metadataContainer) metadataContainer.innerHTML = '';
    if (chartContainer) chartContainer.innerHTML = '';
  }

  renderMetadata() {
    if (!this.currentData) return;

    const container = document.getElementById('metadata-container');
    const metadata = this.currentData.metadata;
    
    if (this.isRankingsMode) {
      this.renderRankingsMetadata(container, metadata);
    } else {
      this.renderComparisonMetadata(container, metadata);
    }
  }

  renderRankingsMetadata(container, metadata) {
    const simulationDate = formatSimulationDate(metadata.timestamp);

    container.innerHTML = `
      <div class="simulation-metadata">
        <h3 class="metadata-title">DPS Rankings Details</h3>
        <div class="metadata-grid">
          <div class="metadata-item">
            <span class="metadata-label">Simulation Type</span>
            <span class="metadata-value">DPS Rankings</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Iterations</span>
            <span class="metadata-value">${metadata.iterations.toLocaleString()}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Specs Tested</span>
            <span class="metadata-value">${metadata.specCount}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Encounter Duration</span>
            <span class="metadata-value">${formatDuration(metadata.encounterDuration)}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Duration Variation</span>
            <span class="metadata-value">±${metadata.encounterVariation}s</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Target Count</span>
            <span class="metadata-value">${metadata.targetCount}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Date Simulated</span>
            <span class="metadata-value">${simulationDate}</span>
          </div>
          <div class="metadata-item metadata-item-wide">
            <span class="metadata-label">Active Raid Buffs</span>
            <span class="metadata-value metadata-value-wrap">${formatRaidBuffs(metadata.raidBuffs)}</span>
          </div>
        </div>
      </div>
    `;
  }

  renderComparisonMetadata(container, metadata) {
    const currentComparisonType = this.getCurrentComparisonType();
    const comparisonLabel = currentComparisonType === 'race' ? 'Race' : 'Trinket';
    const simulationDate = formatSimulationDate(metadata.timestamp);
    const itemCount = Object.keys(this.currentData.results).length;

    container.innerHTML = `
      <div class="simulation-metadata">
        <h3 class="metadata-title">${comparisonLabel} Comparison Details</h3>
        <div class="metadata-grid">
          <div class="metadata-item">
            <span class="metadata-label">Class/Spec</span>
            <span class="metadata-value">${metadata.class || this.getCurrentClass()} ${metadata.spec || this.getCurrentSpec()}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Comparison Type</span>
            <span class="metadata-value">${comparisonLabel}s</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Iterations</span>
            <span class="metadata-value">${metadata.iterations.toLocaleString()}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">${comparisonLabel}s Tested</span>
            <span class="metadata-value">${itemCount}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Encounter Duration</span>
            <span class="metadata-value">${formatDuration(metadata.encounterDuration)}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Duration Variation</span>
            <span class="metadata-value">±${metadata.encounterVariation}s</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Target Count</span>
            <span class="metadata-value">${metadata.targetCount}</span>
          </div>
          <div class="metadata-item">
            <span class="metadata-label">Date Simulated</span>
            <span class="metadata-value">${simulationDate}</span>
          </div>
          <div class="metadata-item metadata-item-wide">
            <span class="metadata-label">Active Raid Buffs</span>
            <span class="metadata-value metadata-value-wrap">${formatRaidBuffs(metadata.raidBuffs)}</span>
          </div>
        </div>
      </div>
    `;
  }

  renderChart() {
    if (!this.currentData) return;

    const container = document.getElementById('chart-container');
    const sortBy = document.getElementById('sortBy').value;
    
    if (this.isRankingsMode) {
      this.renderRankingsChart(container, sortBy);
    } else {
      this.renderComparisonChart(container, sortBy);
    }
  }

  renderRankingsChart(container, sortBy) {
    const chartItems = [];
    
    // Convert rankings data structure
    for (const [className, classData] of Object.entries(this.currentData.results)) {
      for (const [specName, specData] of Object.entries(classData)) {
        chartItems.push({
          label: `${className.replace(/_/g, ' ')} ${specName}`,
          dps: specData.dps,
          max: specData.max,
          min: specData.min,
          stdev: specData.stdev,
          value: specData[sortBy] || specData.dps,
          category: className,
          className: className,
          specName: specName
        });
      }
    }

    // Sort based on selected metric
    if (sortBy === 'stdev') {
      chartItems.sort((a, b) => a.value - b.value); // Lower stdev is better
    } else {
      chartItems.sort((a, b) => b.value - a.value); // Higher values are better
    }

    const maxDps = Math.max(...chartItems.map(item => item.value));
    const minDps = Math.min(...chartItems.map(item => item.value));
    
    const chartTitles = {
      dps: 'DPS Rankings (Average)',
      max: 'DPS Rankings (Maximum)',
      min: 'DPS Rankings (Minimum)', 
      stdev: 'DPS Consistency Rankings (Low StdDev = More Consistent)'
    };
    
    container.innerHTML = `
      <div class="chart-container">
        <h2 class="chart-title">${chartTitles[sortBy] || 'DPS Rankings'}</h2>
        <div class="chart-bars">
          ${chartItems.map((item, index) => {
            // Dynamic scaling based on data spread
            const minBarWidth = 15;
            const maxBarWidth = 100;
            
            // Calculate how spread out the data is
            const valueRange = maxDps - minDps;
            const averageValue = (maxDps + minDps) / 2;
            const coefficientOfVariation = valueRange / averageValue;
            
            // Dynamic scaling weight based on data spread
            // If data is close together (low variation), emphasize differences more
            // If data is spread out (high variation), use more zero-based scaling
            const rangeWeight = Math.min(coefficientOfVariation * 1.5, 0.8); // Cap at 80% range-based
            const zeroWeight = 1 - rangeWeight;
            
            // Calculate both scaling approaches
            const zeroBasedPercentage = item.value / maxDps;
            const rangeBasedPercentage = valueRange > 0 ? (item.value - minDps) / valueRange : 1;
            
            // Blend the two approaches
            const hybridPercentage = (zeroBasedPercentage * zeroWeight) + (rangeBasedPercentage * rangeWeight);
            
            // Apply minimum visibility threshold
            const minThreshold = minBarWidth / maxBarWidth;
            const finalPercentage = Math.max(hybridPercentage, minThreshold);
            const barWidth = finalPercentage * maxBarWidth;
            
            const displayValue = Math.round(item.value).toLocaleString();
            const avgDps = Math.round(item.dps).toLocaleString();
            const tooltip = sortBy === 'dps' ? displayValue : `${displayValue} (Avg: ${avgDps})`;
            
            const barColor = classColors[item.className] || '#666';
            
            return `
            <div class="chart-item">
              <div class="chart-labels">
                <span class="chart-rank">#${index + 1}</span>
                <span class="chart-label">${item.label}</span>
              </div>
              <div class="chart-bar-container">
                <div class="chart-bar-track">
                  <div class="chart-bar" style="width: ${barWidth}%; background-color: ${barColor};"></div>
                </div>
                <span class="chart-value" title="${tooltip}">${displayValue}</span>
              </div>
            </div>
            `;
          }).join('')}
        </div>
      </div>
    `;
  }

  renderComparisonChart(container, sortBy) {
    const currentComparisonType = this.getCurrentComparisonType();
    const comparisonLabel = currentComparisonType === 'race' ? 'Race' : 'Trinket';
    
    const chartItems = [];
    
    for (const [itemName, itemData] of Object.entries(this.currentData.results)) {
      chartItems.push({
        label: itemName.replace(/_/g, ' '),
        dps: itemData.dps,
        max: itemData.max,
        min: itemData.min,
        stdev: itemData.stdev,
        value: itemData[sortBy] || itemData.dps,
        category: itemName,
        rawName: itemName
      });
    }

    // Sort based on selected metric
    if (sortBy === 'stdev') {
      chartItems.sort((a, b) => a.value - b.value); // Lower stdev is better
    } else {
      chartItems.sort((a, b) => b.value - a.value); // Higher values are better
    }

    const maxDps = Math.max(...chartItems.map(item => item.value));
    const minDps = Math.min(...chartItems.map(item => item.value));
    
    const chartTitles = {
      dps: `${comparisonLabel} DPS Rankings (Average)`,
      max: `${comparisonLabel} DPS Rankings (Maximum)`,
      min: `${comparisonLabel} DPS Rankings (Minimum)`, 
      stdev: `${comparisonLabel} DPS Consistency Rankings (Low StdDev = More Consistent)`
    };
    
    container.innerHTML = `
      <div class="chart-container">
        <h2 class="chart-title">${chartTitles[sortBy] || `${comparisonLabel} DPS Rankings`}</h2>
        <div class="chart-bars">
          ${chartItems.map((item, index) => {
            // Dynamic scaling based on data spread
            const minBarWidth = 15;
            const maxBarWidth = 100;
            
            // Calculate how spread out the data is
            const valueRange = maxDps - minDps;
            const averageValue = (maxDps + minDps) / 2;
            const coefficientOfVariation = valueRange / averageValue;
            
            // Dynamic scaling weight based on data spread
            // If data is close together (low variation), emphasize differences more
            // If data is spread out (high variation), use more zero-based scaling
            const rangeWeight = Math.min(coefficientOfVariation * 1.5, 0.8); // Cap at 80% range-based
            const zeroWeight = 1 - rangeWeight;
            
            // Calculate both scaling approaches
            const zeroBasedPercentage = item.value / maxDps;
            const rangeBasedPercentage = valueRange > 0 ? (item.value - minDps) / valueRange : 1;
            
            // Blend the two approaches
            const hybridPercentage = (zeroBasedPercentage * zeroWeight) + (rangeBasedPercentage * rangeWeight);
            
            // Apply minimum visibility threshold
            const minThreshold = minBarWidth / maxBarWidth;
            const finalPercentage = Math.max(hybridPercentage, minThreshold);
            const barWidth = finalPercentage * maxBarWidth;
            
            const displayValue = Math.round(item.value).toLocaleString();
            const avgDps = Math.round(item.dps).toLocaleString();
            const tooltip = sortBy === 'dps' ? displayValue : `${displayValue} (Avg: ${avgDps})`;
            
            // Use class color for race comparisons (since we're comparing races within a class)
            const barColor = currentComparisonType === 'race' ? 
              (classColors[this.getCurrentClass()] || '#666') : '#666';
            
            return `
            <div class="chart-item">
              <div class="chart-labels">
                <span class="chart-rank">#${index + 1}</span>
                <span class="chart-label">${item.label}</span>
              </div>
              <div class="chart-bar-container">
                <div class="chart-bar-track">
                  <div class="chart-bar" style="width: ${barWidth}%; background-color: ${barColor};"></div>
                </div>
                <span class="chart-value" title="${tooltip}">${displayValue}</span>
              </div>
            </div>
            `;
          }).join('')}
        </div>
      </div>
    `;
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing UnifiedChart...');
  new UnifiedChart();
});
    </script>
  </body>
</html>