import { db, eq, and, desc, asc, sql, inArray } from "astro:db";
import {
  dungeons,
  realms,
  challenge_runs,
  players,
  run_members,
  player_profiles,
  player_best_runs,
  player_details,
  player_equipment,
  player_equipment_enchantments,
  items,
} from "astro:db";

// Percentile bracket helper (artifact/legendary/epic/rare/uncommon/common)
function computeBracket(
  rank: number | null | undefined,
  total: number | null | undefined,
): string | null {
  if (!rank || !total || total <= 0) return null;
  if (rank === 1) return "artifact";
  const percentile = ((total - rank) / total) * 100.0;
  if (percentile >= 95.0) return "legendary";
  if (percentile >= 80.0) return "epic";
  if (percentile >= 60.0) return "rare";
  if (percentile >= 40.0) return "uncommon";
  return "common";
}

// helper function to get team members for multiple runs
async function getTeamMembersForRuns(runIds: number[]) {
  if (runIds.length === 0) return {};

  const memberResults = await db
    .select({
      run_id: run_members.run_id,
      name: players.name,
      player_id: players.id,
      spec_id: run_members.spec_id,
      faction: run_members.faction,
      realm_slug: realms.slug,
      region: realms.region,
    })
    .from(run_members)
    .innerJoin(players, eq(run_members.player_id, players.id))
    .innerJoin(realms, eq(players.realm_id, realms.id))
    .where(inArray(run_members.run_id, runIds))
    .orderBy(run_members.run_id, players.name);

  const membersMap: Record<number, any[]> = {};
  memberResults.forEach((row) => {
    if (!membersMap[row.run_id]) membersMap[row.run_id] = [];
    membersMap[row.run_id].push({
      name: row.name,
      id: row.player_id,
      spec_id: row.spec_id,
      faction: row.faction,
      realm_slug: row.realm_slug,
      region: row.region,
    });
  });

  return membersMap;
}

export async function getLeaderboardData(
  region: string,
  realmSlug: string,
  dungeonId: number,
  page: number = 1,
  pageSize: number = 25,
  teamFilter: boolean = false,
) {
  const offset = (page - 1) * pageSize;
  // Order runs by duration ascending for the realm and dungeon
  const results = await db
    .select({
      id: challenge_runs.id,
      duration: challenge_runs.duration,
      completed_timestamp: challenge_runs.completed_timestamp,
      keystone_level: challenge_runs.keystone_level,
      dungeon_name: dungeons.name,
      realm_name: realms.name,
      region: realms.region,
    })
    .from(challenge_runs)
    .innerJoin(dungeons, eq(challenge_runs.dungeon_id, dungeons.id))
    .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
    .where(
      and(
        eq(realms.region, region),
        eq(realms.slug, realmSlug),
        eq(dungeons.id, dungeonId),
      ),
    )
    .orderBy(
      asc(challenge_runs.duration),
      asc(challenge_runs.completed_timestamp),
    )
    .limit(pageSize)
    .offset(offset);

  if (!results.length) {
    return { leading_groups: [] };
  }

  // get team members for each run
  const runIds = results.map((r) => r.id);
  const membersMap = await getTeamMembersForRuns(runIds);

  // add members to runs
  const runs = results.map((run) => ({
    ...run,
    members: membersMap[run.id] || [],
  }));

  // get total count for pagination
  const totalCountResult = await db
    .select({ count: sql`COUNT(*)` })
    .from(challenge_runs)
    .innerJoin(dungeons, eq(challenge_runs.dungeon_id, dungeons.id))
    .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
    .where(
      and(
        eq(realms.region, region),
        eq(realms.slug, realmSlug),
        eq(dungeons.id, dungeonId),
      ),
    );

  const totalRuns = Number(totalCountResult[0]?.count ?? 0);
  const totalPages = Math.ceil(totalRuns / pageSize);

  return {
    leading_groups: runs,
    map: { name: { en_US: runs[0]?.dungeon_name || dungeonId } },
    connected_realm: { name: runs[0]?.realm_name || realmSlug },
    pagination: {
      currentPage: page,
      pageSize: pageSize,
      totalRuns: totalRuns,
      totalPages: totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1,
    },
  };
}

export async function getGlobalLeaderboard(
  dungeonId: number,
  page: number = 1,
  pageSize: number = 25,
  teamFilter: boolean = false,
) {
  const offset = (page - 1) * pageSize;
  // 1) Get team signatures ordered by their best duration (global scope)
  const groups = await db
    .select({
      team_signature: challenge_runs.team_signature,
      best_duration: sql<number>`MIN(${challenge_runs.duration})`,
      best_completed: sql<number>`MIN(${challenge_runs.completed_timestamp})`,
    })
    .from(challenge_runs)
    .where(eq(challenge_runs.dungeon_id, dungeonId))
    .groupBy(challenge_runs.team_signature)
    .orderBy(
      asc(sql`MIN(${challenge_runs.duration})`),
      asc(sql`MIN(${challenge_runs.completed_timestamp})`),
      asc(sql`MIN(${challenge_runs.id})`),
    )
    .limit(pageSize)
    .offset(offset);

  // 2) For each team, pick a canonical run id (earliest completion among best-duration rows)
  const ids: number[] = [];
  for (const g of groups) {
    const pick = await db
      .select({ id: challenge_runs.id })
      .from(challenge_runs)
      .where(
        and(
          eq(challenge_runs.dungeon_id, dungeonId),
          eq(challenge_runs.team_signature, g.team_signature as any),
          eq(challenge_runs.duration, g.best_duration as any),
        ),
      )
      .orderBy(asc(challenge_runs.completed_timestamp), asc(challenge_runs.id))
      .limit(1);
    if (pick[0]) ids.push(pick[0].id as any);
  }

  if (!ids.length) {
    return { leading_groups: [] };
  }

  // 3) Fetch details for the selected run ids and sort in the same order as ids
  const rows = await db
    .select({
      id: challenge_runs.id,
      duration: challenge_runs.duration,
      completed_timestamp: challenge_runs.completed_timestamp,
      keystone_level: challenge_runs.keystone_level,
      dungeon_name: dungeons.name,
      realm_name: realms.name,
      region: realms.region,
    })
    .from(challenge_runs)
    .innerJoin(dungeons, eq(challenge_runs.dungeon_id, dungeons.id))
    .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
    .where(inArray(challenge_runs.id, ids));

  const results = ids
    .map((id) => rows.find((r) => r.id === id))
    .filter(Boolean) as any[];

  if (!results.length) {
    return { leading_groups: [] };
  }

  const runIds = results.map((r) => r.id);
  const membersMap = await getTeamMembersForRuns(runIds);

  const runs = results.map((run) => ({
    ...run,
    members: membersMap[run.id] || [],
  }));

  const totalCountResult = await db
    .select({ count: sql`COUNT(DISTINCT ${challenge_runs.team_signature})` })
    .from(challenge_runs)
    .where(eq(challenge_runs.dungeon_id, dungeonId));

  const totalRuns = Number(totalCountResult[0]?.count ?? 0);
  const totalPages = Math.ceil(totalRuns / pageSize);

  return {
    leading_groups: runs,
    map: { name: { en_US: runs[0]?.dungeon_name || dungeonId } },
    pagination: {
      currentPage: page,
      pageSize: pageSize,
      totalRuns: totalRuns,
      totalPages: totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1,
    },
  };
}

export async function getRegionalLeaderboard(
  region: string,
  dungeonId: number,
  page: number = 1,
  pageSize: number = 25,
  teamFilter: boolean = false,
) {
  const offset = (page - 1) * pageSize;
  // 1) Region-scoped team signatures ordered by best duration
  const groups = await db
    .select({
      team_signature: challenge_runs.team_signature,
      best_duration: sql<number>`MIN(${challenge_runs.duration})`,
      best_completed: sql<number>`MIN(${challenge_runs.completed_timestamp})`,
    })
    .from(challenge_runs)
    .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
    .where(
      and(eq(realms.region, region), eq(challenge_runs.dungeon_id, dungeonId)),
    )
    .groupBy(challenge_runs.team_signature)
    .orderBy(
      asc(sql`MIN(${challenge_runs.duration})`),
      asc(sql`MIN(${challenge_runs.completed_timestamp})`),
      asc(sql`MIN(${challenge_runs.id})`),
    )
    .limit(pageSize)
    .offset(offset);

  const ids: number[] = [];
  for (const g of groups) {
    const pick = await db
      .select({ id: challenge_runs.id })
      .from(challenge_runs)
      .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
      .where(
        and(
          eq(realms.region, region),
          eq(challenge_runs.dungeon_id, dungeonId),
          eq(challenge_runs.team_signature, g.team_signature as any),
          eq(challenge_runs.duration, g.best_duration as any),
        ),
      )
      .orderBy(asc(challenge_runs.completed_timestamp), asc(challenge_runs.id))
      .limit(1);
    if (pick[0]) ids.push(pick[0].id as any);
  }

  if (!ids.length) {
    return { leading_groups: [] };
  }

  const rows = await db
    .select({
      id: challenge_runs.id,
      duration: challenge_runs.duration,
      completed_timestamp: challenge_runs.completed_timestamp,
      keystone_level: challenge_runs.keystone_level,
      dungeon_name: dungeons.name,
      realm_name: realms.name,
      region: realms.region,
    })
    .from(challenge_runs)
    .innerJoin(dungeons, eq(challenge_runs.dungeon_id, dungeons.id))
    .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
    .where(inArray(challenge_runs.id, ids));

  const results = ids
    .map((id) => rows.find((r) => r.id === id))
    .filter(Boolean) as any[];

  if (!results.length) {
    return { leading_groups: [] };
  }

  const runIds = results.map((r) => r.id);
  const membersMap = await getTeamMembersForRuns(runIds);

  const runs = results.map((run) => ({
    ...run,
    members: membersMap[run.id] || [],
  }));

  const totalCountResult = await db
    .select({ count: sql`COUNT(DISTINCT ${challenge_runs.team_signature})` })
    .from(challenge_runs)
    .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
    .where(
      and(eq(realms.region, region), eq(challenge_runs.dungeon_id, dungeonId)),
    );

  const totalRuns = Number(totalCountResult[0]?.count ?? 0);
  const totalPages = Math.ceil(totalRuns / pageSize);

  return {
    leading_groups: runs,
    map: { name: { en_US: runs[0]?.dungeon_name || dungeonId } },
    pagination: {
      currentPage: page,
      pageSize: pageSize,
      totalRuns: totalRuns,
      totalPages: totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1,
    },
  };
}

export async function getPlayerProfile(
  region: string,
  realmSlug: string,
  playerName: string,
) {
  const results = await db
    .select({
      id: players.id,
      name: players.name,
      realm_slug: realms.slug,
      realm_name: realms.name,
      region: realms.region,
      race_name: player_details.race_name,
      gender: player_details.gender,
      class_name: player_details.class_name,
      active_spec_name: player_details.active_spec_name,
      guild_name: player_details.guild_name,
      level: player_details.level,
      average_item_level: player_details.average_item_level,
      equipped_item_level: player_details.equipped_item_level,
      global_ranking: player_profiles.global_ranking,
      regional_ranking: player_profiles.regional_ranking,
      realm_ranking: player_profiles.realm_ranking,
      global_ranking_bracket: player_profiles.global_ranking_bracket,
      regional_ranking_bracket: player_profiles.regional_ranking_bracket,
      realm_ranking_bracket: player_profiles.realm_ranking_bracket,
      combined_best_time: player_profiles.combined_best_time,
      dungeons_completed: player_profiles.dungeons_completed,
      total_runs: player_profiles.total_runs,
    })
    .from(players)
    .innerJoin(realms, eq(players.realm_id, realms.id))
    .leftJoin(player_details, eq(players.id, player_details.player_id))
    .leftJoin(player_profiles, eq(players.id, player_profiles.player_id))
    .where(
      and(
        eq(realms.region, region),
        eq(realms.slug, realmSlug),
        sql`LOWER(${players.name}) = ${playerName.toLowerCase()}`,
      ),
    );

  return results[0] || null;
}

export async function getPlayerEquipment(playerId: number) {
  // get latest equipment snapshot
  const equipmentResults = await db
    .select({
      id: player_equipment.id,
      slot_type: player_equipment.slot_type,
      item_id: player_equipment.item_id,
      upgrade_id: player_equipment.upgrade_id,
      quality: player_equipment.quality,
      item_name: player_equipment.item_name,
      snapshot_timestamp: player_equipment.snapshot_timestamp,
      item_icon_slug: items.icon,
      item_type: items.type,
    })
    .from(player_equipment)
    .leftJoin(items, eq(player_equipment.item_id, items.id))
    .where(
      and(
        eq(player_equipment.player_id, playerId),
        eq(
          player_equipment.snapshot_timestamp,
          db
            .select({ max: sql`MAX(snapshot_timestamp)` })
            .from(player_equipment)
            .where(eq(player_equipment.player_id, playerId)),
        ),
      ),
    )
    .orderBy(player_equipment.slot_type);

  if (!equipmentResults.length) {
    return {};
  }

  const equipment: Record<string, any> = {};
  const equipmentIds = equipmentResults.map((e) => e.id);

  equipmentResults.forEach((row) => {
    equipment[row.slot_type] = {
      ...row,
      enchantments: [],
    };
  });

  // get enchantments
  if (equipmentIds.length > 0) {
    const enchantResults = await db
      .select({
        equipment_id: player_equipment_enchantments.equipment_id,
        enchantment_id: player_equipment_enchantments.enchantment_id,
        slot_id: player_equipment_enchantments.slot_id,
        slot_type: player_equipment_enchantments.slot_type,
        display_string: player_equipment_enchantments.display_string,
        source_item_id: player_equipment_enchantments.source_item_id,
        source_item_name: player_equipment_enchantments.source_item_name,
        spell_id: player_equipment_enchantments.spell_id,
        gem_icon_slug: items.icon,
        gem_name: items.name,
      })
      .from(player_equipment_enchantments)
      .leftJoin(
        items,
        eq(player_equipment_enchantments.source_item_id, items.id),
      )
      .where(inArray(player_equipment_enchantments.equipment_id, equipmentIds))
      .orderBy(
        player_equipment_enchantments.equipment_id,
        player_equipment_enchantments.slot_id,
      );

    enchantResults.forEach((row) => {
      for (const [, item] of Object.entries(equipment)) {
        if ((item as any).id === row.equipment_id) {
          (item as any).enchantments.push({
            enchantment_id: row.enchantment_id,
            slot_id: row.slot_id,
            slot_type: row.slot_type,
            display_string: row.display_string,
            source_item_id: row.source_item_id,
            source_item_name: row.source_item_name,
            spell_id: row.spell_id,
            gem_icon_slug: row.gem_icon_slug,
            gem_name: row.gem_name,
          });
          break;
        }
      }
    });
  }

  return equipment;
}

export async function getPlayerBestRuns(playerId: number) {
  const bestRunsResults = await db
    .select({
      dungeon_id: player_best_runs.dungeon_id,
      duration: player_best_runs.duration,
      global_ranking: player_best_runs.global_ranking,
      global_ranking_filtered: player_best_runs.global_ranking_filtered,
      regional_ranking_filtered: player_best_runs.regional_ranking_filtered,
      realm_ranking_filtered: player_best_runs.realm_ranking_filtered,
      completed_timestamp: player_best_runs.completed_timestamp,
      dungeon_name: dungeons.name,
      dungeon_slug: dungeons.slug,
      run_id: player_best_runs.run_id,
      keystone_level: challenge_runs.keystone_level,
      regional_ranking: player_best_runs.regional_ranking,
      realm_ranking: player_best_runs.realm_ranking,
      percentile_bracket: player_best_runs.percentile_bracket,
      global_percentile_bracket: player_best_runs.global_percentile_bracket,
      regional_percentile_bracket: player_best_runs.regional_percentile_bracket,
      realm_percentile_bracket: player_best_runs.realm_percentile_bracket,
      region: realms.region,
      realm_id: realms.id,
      realm_slug: realms.slug,
    })
    .from(player_best_runs)
    .innerJoin(dungeons, eq(player_best_runs.dungeon_id, dungeons.id))
    .innerJoin(challenge_runs, eq(player_best_runs.run_id, challenge_runs.id))
    .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
    .where(eq(player_best_runs.player_id, playerId))
    .orderBy(dungeons.name);

  if (!bestRunsResults.length) {
    return {};
  }

  const bestRuns: Record<string, any> = {};
  const runIds = bestRunsResults.map((r) => r.run_id);

  bestRunsResults.forEach((row) => {
    bestRuns[row.dungeon_slug] = {
      ...row,
      team_members: [],
    };
  });

  const membersMap = await getTeamMembersForRuns(runIds);

  for (const [, run] of Object.entries(bestRuns)) {
    (run as any).team_members = membersMap[(run as any).run_id] || [];
  }

  return bestRuns;
}

// Variant that returns ranks per dungeon for the player's best runs
export async function getPlayerBestRunsWithRanks(playerId: number) {
  const bestRuns = await getPlayerBestRuns(playerId);
  const entries = Object.entries(bestRuns);
  if (!entries.length) return bestRuns;

  for (const [slug, run] of entries) {
    const dungeonId = (run as any).dungeon_id as number;
    const duration = (run as any).duration as number;
    const completed = (run as any).completed_timestamp as number;

    const cr = await db
      .select({
        team_signature: challenge_runs.team_signature,
        region: realms.region,
        realm_slug: realms.slug,
      })
      .from(challenge_runs)
      .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
      .where(eq(challenge_runs.id, (run as any).run_id as number));
    const region = cr[0]?.region as string | undefined;
    const realmSlug = cr[0]?.realm_slug as string | undefined;

    const countBetter = async (scope: "global" | "regional" | "realm") => {
      const conditions: any[] = [eq(challenge_runs.dungeon_id, dungeonId)];
      if (scope === "regional" && region)
        conditions.push(eq(realms.region, region));
      if (scope === "realm" && region && realmSlug) {
        conditions.push(eq(realms.region, region));
        conditions.push(eq(realms.slug, realmSlug));
      }
      const rows = await db
        .select({ cnt: sql<number>`COUNT(*)` })
        .from(challenge_runs)
        .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
        .where(and(...conditions))
        .groupBy(challenge_runs.team_signature)
        .having(
          sql`MIN(${challenge_runs.duration}) < ${duration} OR (MIN(${challenge_runs.duration}) = ${duration} AND MIN(${challenge_runs.completed_timestamp}) < ${completed})`,
        );
      return rows.length;
    };

    const globalRank = (await countBetter("global")) + 1;
    const regionalRank = region ? (await countBetter("regional")) + 1 : null;
    const realmRank =
      region && realmSlug ? (await countBetter("realm")) + 1 : null;

    // totals for percentile brackets (team-deduped totals using DISTINCT team_signature)
    const countTotal = async (scope: "global" | "regional" | "realm") => {
      const conditions: any[] = [eq(challenge_runs.dungeon_id, dungeonId)];
      if (scope === "regional" && region)
        conditions.push(eq(realms.region, region));
      if (scope === "realm" && region && realmSlug) {
        conditions.push(eq(realms.region, region));
        conditions.push(eq(realms.slug, realmSlug));
      }
      const rows = await db
        .select({
          cnt: sql<number>`COUNT(DISTINCT ${challenge_runs.team_signature})`,
        })
        .from(challenge_runs)
        .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
        .where(and(...conditions));
      return Number(rows[0]?.cnt ?? 0);
    };

    const globalTotal = await countTotal("global");
    const regionalTotal = region ? await countTotal("regional") : null;
    const realmTotal = region && realmSlug ? await countTotal("realm") : null;

    // Determine scope min durations to detect true ties for first (artifact color for any tied best time)
    const minDurationFor = async (scope: "global" | "regional" | "realm") => {
      const conditions: any[] = [eq(challenge_runs.dungeon_id, dungeonId)];
      if (scope === "regional" && region)
        conditions.push(eq(realms.region, region));
      if (scope === "realm" && region && realmSlug) {
        conditions.push(eq(realms.region, region));
        conditions.push(eq(realms.slug, realmSlug));
      }
      const rows = await db
        .select({ minDur: sql<number>`MIN(${challenge_runs.duration})` })
        .from(challenge_runs)
        .innerJoin(realms, eq(challenge_runs.realm_id, realms.id))
        .where(and(...conditions));
      return Number(rows[0]?.minDur ?? 0);
    };

    const globalMin = await minDurationFor("global");
    const regionalMin = region ? await minDurationFor("regional") : null;
    const realmMin = region && realmSlug ? await minDurationFor("realm") : null;

    let globalBracket = computeBracket(globalRank, globalTotal);
    let regionalBracket = computeBracket(
      regionalRank as any,
      regionalTotal as any,
    );
    let realmBracket = computeBracket(realmRank as any, realmTotal as any);

    if (duration === globalMin && globalTotal) globalBracket = "artifact";
    if (regionalMin !== null && duration === regionalMin && regionalTotal)
      regionalBracket = "artifact";
    if (realmMin !== null && duration === realmMin && realmTotal)
      realmBracket = "artifact";

    (bestRuns as any)[slug] = {
      ...(run as any),
      // Prefer filtered-style fields used by the renderer
      global_ranking_filtered: globalRank,
      regional_ranking_filtered: regionalRank,
      realm_ranking_filtered: realmRank,
      // Also keep non-filtered fields for compatibility if referenced elsewhere
      global_ranking: globalRank,
      regional_ranking: regionalRank,
      realm_ranking: realmRank,
      // Percentile brackets per scope
      global_percentile_bracket: globalBracket,
      regional_percentile_bracket: regionalBracket,
      realm_percentile_bracket: realmBracket,
      // Fallback generic percentile_bracket as global scope
      percentile_bracket: globalBracket,
    };
  }

  return bestRuns;
}

export async function getPlayerLeaderboard(
  scope: string = "global",
  region: string | null = null,
  page: number = 1,
  pageSize: number = 25,
) {
  const offset = (page - 1) * pageSize;

  const base = db
    .select({
      player_id: players.id,
      name: players.name,
      realm_slug: realms.slug,
      realm_name: realms.name,
      region: realms.region,
      class_name: player_details.class_name,
      active_spec_name: player_details.active_spec_name,
      main_spec_id: player_profiles.main_spec_id,
      combined_best_time: player_profiles.combined_best_time,
      dungeons_completed: player_profiles.dungeons_completed,
      total_runs: player_profiles.total_runs,
    })
    .from(players)
    .innerJoin(realms, eq(players.realm_id, realms.id))
    .innerJoin(player_profiles, eq(players.id, player_profiles.player_id))
    .leftJoin(player_details, eq(players.id, player_details.player_id));

  let rows: any[] = [];
  if (scope === "global") {
    rows = await (base as any)
      .where(
        and(
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      )
      .orderBy(asc(player_profiles.combined_best_time), asc(players.name))
      .limit(pageSize)
      .offset(offset);
  } else if (scope === "regional" && region) {
    rows = await (base as any)
      .where(
        and(
          eq(realms.region, region),
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      )
      .orderBy(asc(player_profiles.combined_best_time), asc(players.name))
      .limit(pageSize)
      .offset(offset);
  } else {
    // default: global ordering
    rows = await (base as any)
      .where(sql`${player_profiles.combined_best_time} IS NOT NULL`)
      .orderBy(asc(player_profiles.combined_best_time), asc(players.name))
      .limit(pageSize)
      .offset(offset);
  }

  // total count for pagination
  const countGlobal = () =>
    db
      .select({ count: sql`COUNT(*)` })
      .from(player_profiles)
      .where(
        and(
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      );

  const countRegional = (reg: string) =>
    db
      .select({ count: sql`COUNT(*)` })
      .from(player_profiles)
      .innerJoin(players, eq(player_profiles.player_id, players.id))
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .where(
        and(
          eq(realms.region, reg),
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      );

  const totalCountResult = await (scope === "regional" && region
    ? countRegional(region)
    : countGlobal());

  const totalPlayers = Number(totalCountResult[0]?.count ?? 0);
  const totalPages = Math.ceil(totalPlayers / pageSize);

  return {
    leaderboard: rows,
    title:
      scope === "global"
        ? "Global Player Rankings"
        : `${region?.toUpperCase()} Player Rankings`,
    generated_timestamp: Date.now(),
    pagination: {
      currentPage: page,
      pageSize,
      totalPlayers,
      totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1,
      totalRuns: totalPlayers,
    },
  };
}

export async function getCompletePlayerProfile(
  region: string,
  realmSlug: string,
  playerName: string,
) {
  // get player basic info
  const playerResults = await db
    .select({
      id: players.id,
      name: players.name,
      realm_slug: realms.slug,
      realm_name: realms.name,
      region: realms.region,
      race_id: player_details.race_id,
      race_name: player_details.race_name,
      gender: player_details.gender,
      class_name: player_details.class_name,
      active_spec_name: player_details.active_spec_name,
      guild_name: player_details.guild_name,
      level: player_details.level,
      average_item_level: player_details.average_item_level,
      equipped_item_level: player_details.equipped_item_level,
      avatar_url: player_details.avatar_url,
      global_ranking: player_profiles.global_ranking,
      regional_ranking: player_profiles.regional_ranking,
      realm_ranking: player_profiles.realm_ranking,
      global_ranking_bracket: player_profiles.global_ranking_bracket,
      regional_ranking_bracket: player_profiles.regional_ranking_bracket,
      realm_ranking_bracket: player_profiles.realm_ranking_bracket,
      combined_best_time: player_profiles.combined_best_time,
      dungeons_completed: player_profiles.dungeons_completed,
      total_runs: player_profiles.total_runs,
      has_complete_coverage: player_profiles.has_complete_coverage,
    })
    .from(players)
    .innerJoin(realms, eq(players.realm_id, realms.id))
    .innerJoin(player_details, eq(players.id, player_details.player_id))
    .innerJoin(player_profiles, eq(players.id, player_profiles.player_id))
    .where(
      and(
        eq(realms.region, region),
        eq(realms.slug, realmSlug),
        eq((players as any).name_lower, playerName.toLowerCase()),
        sql`${player_profiles.has_complete_coverage} = 1`,
      ),
    );

  if (!playerResults.length) {
    return { player: null, equipment: {}, bestRuns: {} };
  }

  const player = playerResults[0];
  // Defensive guard: ensure we have a valid player id before proceeding
  if (!player || player.id == null) {
    return { player: null, equipment: {}, bestRuns: {} };
  }

  // helper to compute overall ranks (global/regional/realm) from combined_best_time
  async function computeOverallRanksForPlayer(p: any) {
    // guard: need combined time
    if (!p?.combined_best_time) {
      return {
        global_ranking: null,
        global_ranking_bracket: null,
        regional_ranking: null,
        regional_ranking_bracket: null,
        realm_ranking: null,
        realm_ranking_bracket: null,
      };
    }

    // total qualified players (complete coverage + non-null time)
    const globalTotalRows = await db
      .select({ cnt: sql<number>`COUNT(*)` })
      .from(player_profiles)
      .where(
        and(
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      );
    const globalTotal = Number(globalTotalRows[0]?.cnt ?? 0);

    // number of players strictly better combined time, with tiebreakers by name_lower and id for stability
    const betterThanWhere = (extra?: any) =>
      and(
        sql`${player_profiles.has_complete_coverage} = 1`,
        sql`${player_profiles.combined_best_time} IS NOT NULL`,
        sql`(${player_profiles.combined_best_time} < ${p.combined_best_time}
            OR (${player_profiles.combined_best_time} = ${p.combined_best_time} AND LOWER(${players.name}) < ${p.name.toLowerCase()} )
            OR (${player_profiles.combined_best_time} = ${p.combined_best_time} AND LOWER(${players.name}) = ${p.name.toLowerCase()} AND ${player_profiles.player_id} < ${p.id}))`,
        extra ?? sql`1=1`,
      );

    const countBetterGlobalRows = await db
      .select({ cnt: sql<number>`COUNT(*)` })
      .from(player_profiles)
      .innerJoin(players, eq(player_profiles.player_id, players.id))
      .where(betterThanWhere());
    const globalRank = Number(countBetterGlobalRows[0]?.cnt ?? 0) + 1;
    let globalBracket = computeBracket(globalRank, globalTotal);

    // regional
    const regionalTotalRows = await db
      .select({ cnt: sql<number>`COUNT(*)` })
      .from(player_profiles)
      .innerJoin(players, eq(player_profiles.player_id, players.id))
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .where(
        and(
          eq(realms.region, p.region),
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      );
    const regionalTotal = Number(regionalTotalRows[0]?.cnt ?? 0);

    const countBetterRegionalRows = await db
      .select({ cnt: sql<number>`COUNT(*)` })
      .from(player_profiles)
      .innerJoin(players, eq(player_profiles.player_id, players.id))
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .where(and(eq(realms.region, p.region), betterThanWhere()));
    const regionalRank = Number(countBetterRegionalRows[0]?.cnt ?? 0) + 1;
    let regionalBracket = computeBracket(regionalRank, regionalTotal);

    // realm
    const realmTotalRows = await db
      .select({ cnt: sql<number>`COUNT(*)` })
      .from(player_profiles)
      .innerJoin(players, eq(player_profiles.player_id, players.id))
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .where(
        and(
          eq(realms.region, p.region),
          eq(realms.slug, p.realm_slug),
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      );
    const realmTotal = Number(realmTotalRows[0]?.cnt ?? 0);

    const countBetterRealmRows = await db
      .select({ cnt: sql<number>`COUNT(*)` })
      .from(player_profiles)
      .innerJoin(players, eq(player_profiles.player_id, players.id))
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .where(
        and(
          eq(realms.region, p.region),
          eq(realms.slug, p.realm_slug),
          betterThanWhere(),
        ),
      );
    const realmRank = Number(countBetterRealmRows[0]?.cnt ?? 0) + 1;
    let realmBracket = computeBracket(realmRank, realmTotal);

    // Upgrade to artifact bracket if tied for first by combined time (ignoring tiebreakers)
    const globalMinRows = await db
      .select({
        minTime: sql<number>`MIN(${player_profiles.combined_best_time})`,
      })
      .from(player_profiles)
      .where(
        and(
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      );
    const globalMin = Number(globalMinRows[0]?.minTime ?? null);
    if (globalMin && p.combined_best_time === globalMin)
      globalBracket = "artifact";

    const regionalMinRows = await db
      .select({
        minTime: sql<number>`MIN(${player_profiles.combined_best_time})`,
      })
      .from(player_profiles)
      .innerJoin(players, eq(player_profiles.player_id, players.id))
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .where(
        and(
          eq(realms.region, p.region),
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      );
    const regionalMin = Number(regionalMinRows[0]?.minTime ?? null);
    if (regionalMin && p.combined_best_time === regionalMin)
      regionalBracket = "artifact";

    const realmMinRows = await db
      .select({
        minTime: sql<number>`MIN(${player_profiles.combined_best_time})`,
      })
      .from(player_profiles)
      .innerJoin(players, eq(player_profiles.player_id, players.id))
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .where(
        and(
          eq(realms.region, p.region),
          eq(realms.slug, p.realm_slug),
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${player_profiles.combined_best_time} IS NOT NULL`,
        ),
      );
    const realmMin = Number(realmMinRows[0]?.minTime ?? null);
    if (realmMin && p.combined_best_time === realmMin)
      realmBracket = "artifact";

    return {
      global_ranking: globalRank,
      global_ranking_bracket: globalBracket,
      regional_ranking: regionalRank,
      regional_ranking_bracket: regionalBracket,
      realm_ranking: realmRank,
      realm_ranking_bracket: realmBracket,
    };
  }

  // get equipment and best runs (with per-dungeon ranks) in parallel
  const [equipment, bestRuns, overallRanks] = await Promise.all([
    getPlayerEquipment(player.id),
    getPlayerBestRunsWithRanks(player.id),
    computeOverallRanksForPlayer(player),
  ]);

  const mergedPlayer = {
    ...player,
    ...overallRanks,
  };

  return { player: mergedPlayer, equipment, bestRuns };
}

export async function getPlayerSearchIndex(
  limit: number = 5000,
  offset: number = 0,
) {
  try {
    console.log(
      `ðŸ” Generating player search index: limit=${limit}, offset=${offset}`,
    );

    // Only include players with complete coverage (those who have player profiles)
    // This ensures we only search among players with actual data and class info
    // Select minimal fields used by the search UI
    let results = await db
      .select({
        id: players.id,
        name: players.name,
        realm_slug: realms.slug,
        realm_name: realms.name,
        region: realms.region,
        class_name: player_details.class_name,
        global_ranking: player_profiles.global_ranking,
        global_ranking_bracket: player_profiles.global_ranking_bracket,
      })
      .from(players)
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .innerJoin(player_profiles, eq(players.id, player_profiles.player_id))
      .innerJoin(player_details, eq(players.id, player_details.player_id))
      .where(
        and(
          sql`${player_profiles.has_complete_coverage} = 1`,
          sql`${players.name} IS NOT NULL`,
        ),
      )
      .orderBy(
        asc(player_profiles.global_ranking), // Prioritize globally ranked players
        asc(players.name), // Then alphabetical
      )
      .limit(limit)
      .offset(offset);

    // No fallback here: we only return eligible players (complete coverage)

    // Get total player count for metadata (only players with complete coverage)
    const totalCountResult = await db
      .select({ count: sql`COUNT(*)` })
      .from(players)
      .innerJoin(realms, eq(players.realm_id, realms.id))
      .innerJoin(player_profiles, eq(players.id, player_profiles.player_id))
      .innerJoin(player_details, eq(players.id, player_details.player_id))
      .where(sql`${player_profiles.has_complete_coverage} = 1`);

    const totalPlayers = Number(totalCountResult[0]?.count || 0);

    // transform results to search format
    const searchPlayers = results.map((player) => ({
      id: player.id,
      name: player.name,
      realm_slug: player.realm_slug,
      realm_name: player.realm_name,
      region: player.region,
      class_name: player.class_name || "",
      global_ranking: player.global_ranking,
      global_ranking_bracket: player.global_ranking_bracket,
    }));

    const response = {
      players: searchPlayers,
      metadata: {
        total_players: totalPlayers,
        returned_players: searchPlayers.length,
        offset,
        limit,
        last_updated: new Date().toISOString(),
      },
    };

    console.log(
      `Generated search index: ${searchPlayers.length} players (${totalPlayers} total)`,
    );
    return response;
  } catch (error) {
    console.error("Error generating player search index:", error);
    throw error;
  }
}
