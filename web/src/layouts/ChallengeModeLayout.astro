---
import PageLayout from "../components/PageLayout.astro";
import ControlPanel from "../components/ControlPanel.astro";
import FormSelect from "../components/FormSelect.astro";
import HorizontalSelector from "../components/HorizontalSelector.astro";
import LoadingState from "../components/LoadingState.astro";
import WoWClassColors from "../components/WoWClassColors.astro";
import { DATA_MAP } from "../data/realms.js";
import "../styles/components.scss";

export interface Props {
  initialLeaderboardType?: string;
  initialRegion?: string;
  initialRealm?: string;
  initialDungeon?: string;
}

const {
  initialLeaderboardType = "dungeon",
  initialRegion = "",
  initialRealm = "",
  initialDungeon = "",
} = Astro.props;
const baseUrl = import.meta.env.BASE_URL;
---

<PageLayout
  title="Challenge Mode Leaderboards"
  description=""
  pageTitle="Challenge Mode Leaderboards - MoP Classic"
>
  <WoWClassColors />

  <style>
    .leaderboard-container {
      overflow: hidden;
      margin-top: 20px;
    }

    .loading-overlay,
    .error-overlay {
      min-width: 300px;
    }

    #content {
      min-height: 400px;
      transition: opacity 0.2s ease;
    }

    .content-loading {
      opacity: 0.3;
      pointer-events: none;
    }

    .no-data-message {
      margin: 20px 0;
    }

    .no-data-content {
      text-align: center;
      padding: 40px 20px;
    }

    .no-data-content p {
      color: var(--text-secondary);
      margin: 0;
      font-size: 1.1em;
    }

    #leaderboard-rows {
      display: table;
      width: 100%;
    }
    @media (max-width: 1024px) {
      .leaderboard-header,
      .leaderboard-row {
        grid-template-columns: 60px 100px 1fr 80px 120px;
        gap: 15px;
      }

      .player {
        min-width: 75px;
        font-size: 0.75em;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }

      .leaderboard-header,
      .leaderboard-row {
        grid-template-columns: 1fr;
        gap: 10px;
        text-align: center;
        padding: 10px 15px;
      }

      .team-composition {
        justify-content: center;
      }

      .player {
        min-width: 70px;
        font-size: 0.75em;
      }

      .controls-grid {
        flex-direction: column;
      }

      .rank,
      .duration,
      .mythic-rating,
      .completed-time {
        font-size: 1.1em;
        margin: 5px 0;
      }
    }

    /* Callout component styles */
    .callout {
      background-color: #2a3a3a;
      border: 1px solid #458588;
      border-left: 4px solid #458588;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .callout-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .callout-icon {
      width: 20px;
      height: 20px;
      color: #458588;
      flex-shrink: 0;
    }

    .callout-title {
      color: #458588;
      margin: 0;
      font-size: 1em;
      font-weight: 600;
    }

    .callout-content {
      color: var(--text-primary);
      line-height: 1.5;
      margin-left: 30px;
    }

    .callout-content p {
      margin: 0 0 8px 0;
    }

    .callout-content p:last-child {
      margin-bottom: 0;
    }

    .callout-content a {
      color: #458588;
      text-decoration: none;
    }

    .callout-content a:hover {
      text-decoration: underline;
    }

    .callout-content strong {
      color: #458588;
    }

    .callout-content code {
      background-color: rgba(255, 255, 255, 0.1);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: "Courier New", monospace;
      font-size: 0.9em;
    }

    /* Checkbox styling */
    .form-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }

    .checkbox-input {
      width: 18px;
      height: 18px;
      appearance: none;
      background-color: var(--bg-primary);
      border: 2px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s ease;
    }

    .checkbox-input:checked {
      background-color: var(--highlight-color);
      border-color: var(--highlight-color);
    }

    .checkbox-input:checked::after {
      content: "✓";
      position: absolute;
      top: -1px;
      left: 2px;
      color: #000;
      font-size: 14px;
      font-weight: bold;
    }

    .checkbox-input:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(218, 165, 32, 0.2);
    }

    .checkbox-input:hover {
      border-color: var(--highlight-color);
    }

    .checkbox-label {
      font-size: 14px;
      color: var(--text-primary);
      cursor: pointer;
      user-select: none;
    }

    .checkbox-label:hover {
      color: var(--highlight-color);
    }
  </style>

  <ControlPanel title="Leaderboard Options">
    <FormSelect
      id="leaderboard-type"
      label="Leaderboard Type"
      options={[
        {
          value: "dungeon",
          label: "Dungeons",
          selected: initialLeaderboardType === "dungeon",
        },
        {
          value: "players",
          label: "Players",
          selected: initialLeaderboardType === "players",
        },
        {
          value: "teams",
          label: "Teams (Experimental)",
          selected: initialLeaderboardType === "teams",
        },
      ]}
    />
    <div id="dungeon-selectors" style="display: none;">
      <FormSelect
        id="region"
        label="Region"
        options={[
          { value: "", label: "Select Region", selected: initialRegion === "" },
          { value: "us", label: "US", selected: initialRegion === "us" },
          { value: "eu", label: "EU", selected: initialRegion === "eu" },
          { value: "kr", label: "KR", selected: initialRegion === "kr" },
          {
            value: "global",
            label: "Global",
            selected: initialRegion === "global",
          },
        ]}
      />
      <FormSelect
        id="realm"
        label="Realm"
        options={[{ value: "", label: "Select Region First", selected: true }]}
      />
      <HorizontalSelector
        id="dungeon"
        label="Dungeon"
        options={[
          {
            value: "2",
            label: "Temple of the Jade Serpent",
            selected: initialDungeon === "2",
          },
          {
            value: "56",
            label: "Stormstout Brewery",
            selected: initialDungeon === "56",
          },
          {
            value: "57",
            label: "Gate of the Setting Sun",
            selected: initialDungeon === "57",
          },
          {
            value: "58",
            label: "Shado-Pan Monastery",
            selected: initialDungeon === "58",
          },
          {
            value: "59",
            label: "Siege of Niuzao Temple",
            selected: initialDungeon === "59",
          },
          {
            value: "60",
            label: "Mogu'shan Palace",
            selected: initialDungeon === "60",
          },
          {
            value: "76",
            label: "Scholomance",
            selected: initialDungeon === "76",
          },
          {
            value: "77",
            label: "Scarlet Halls",
            selected: initialDungeon === "77",
          },
          {
            value: "78",
            label: "Scarlet Monastery",
            selected: initialDungeon === "78",
          },
        ]}
      />

      <!-- Team Filter Toggle -->
      <div class="form-group">
        <label for="team-filter" class="form-label">Filter Teams</label>
        <div class="form-checkbox">
          <input
            type="checkbox"
            id="team-filter"
            class="checkbox-input"
            checked
          />
          <label for="team-filter" class="checkbox-label"
            >Show best time per team</label
          >
        </div>
      </div>
    </div>
  </ControlPanel>

  <div id="teams-callout" class="callout" style="display: none;">
    <div class="callout-content">
      <p><strong>Team Leaderboards (Work in Progress)</strong></p>
      <p>
        Team rankings attempt to rank teams by identifying 3 core players and
        building an extended roster from that. Rankings are based on the sum of
        their best times across all dungeons.
      </p>
      <p>
        <em
          >This feature is still being actively developed, teams, particularly
          ones with large overlapping rosters are still being identified
          incorrectly.
        </em>
      </p>
    </div>
  </div>
</PageLayout>

<div id="loading" class="loading-overlay hidden">
  <LoadingState message="Loading Challenge Mode leaderboard data..." />
</div>

<div id="error" class="error-overlay hidden">
  <LoadingState type="error" />
</div>

<div id="no-data" class="no-data-message hidden">
  <div class="card">
    <div class="no-data-content">
      <h3 class="section-title-large">No Times Found</h3>
      <p>
        No Challenge Mode times were found for this realm and dungeon
        combination.
      </p>
    </div>
  </div>
</div>

<div id="content" class="hidden">
  <div class="card">
    <div class="info-grid">
      <div class="info-item">
        <span class="info-label">Dungeon</span>
        <span class="info-value" id="dungeon-name">Loading...</span>
      </div>
      <div class="info-item">
        <span class="info-label">Period</span>
        <span class="info-value" id="period">-</span>
      </div>
      <div class="info-item">
        <span class="info-label">Realm</span>
        <span class="info-value" id="realm-name">-</span>
      </div>
      <div class="info-item">
        <span class="info-label">Period Start</span>
        <span class="info-value" id="period-start">-</span>
      </div>
      <div class="info-item">
        <span class="info-label">Period End</span>
        <span class="info-value" id="period-end">-</span>
      </div>
    </div>

    <div
      id="cross-realm-note"
      style="display: none; margin-top: 15px; padding: 10px; background-color: rgba(255, 107, 107, 0.1); border-left: 3px solid #ff6b6b; border-radius: 4px;"
    >
      <p style="margin: 0; font-size: 0.85em; color: var(--text-secondary);">
        <span style="color: #ff6b6b; font-weight: bold;">*</span> indicates players
        from other realms. Times with 3+ local players represent the true realm record
        for Feat of Strength achievement.
      </p>
    </div>
  </div>

  <div class="leaderboard-container card-container" id="dungeon-leaderboard">
    <div id="leaderboard-rows"></div>
  </div>

  <div
    class="leaderboard-container card"
    id="team-player-leaderboard"
    style="display: none;"
  >
    <div id="team-rows"></div>
  </div>
</div>

<style is:global>
  /* Global styles for dynamically generated content */
  #leaderboard-rows .leaderboard-row {
    display: grid !important;
    grid-template-columns: 80px 120px 2fr 100px 140px !important;
    gap: 20px !important;
    align-items: center !important;
    padding: 15px 20px !important;
    border-bottom: 1px solid #4a4a4a !important;
    min-height: 60px !important;
  }

  #leaderboard-rows .rank {
    font-size: 1.2em !important;
    font-weight: bold !important;
    text-align: center !important;
    color: #d8a657 !important;
  }

  #leaderboard-rows .duration {
    font-family: "Courier New", monospace !important;
    font-weight: bold !important;
    color: #00ff88 !important;
    text-align: right !important;
  }

  #leaderboard-rows .team-composition {
    display: flex !important;
    flex-wrap: wrap !important;
    gap: 6px !important;
    justify-content: flex-start !important;
    align-items: center !important;
  }

  #leaderboard-rows .mythic-rating {
    color: #d8a657 !important;
    font-weight: bold !important;
    text-align: center !important;
  }

  #leaderboard-rows .completed-time {
    color: #aaaaaa !important;
    font-size: 0.9em !important;
    text-align: center !important;
  }

  @media (max-width: 1024px) {
    #leaderboard-rows .leaderboard-row {
      grid-template-columns: 60px 100px 1fr 80px 120px !important;
      gap: 15px !important;
    }
  }

  @media (max-width: 768px) {
    #leaderboard-rows .leaderboard-row {
      grid-template-columns: 1fr !important;
      gap: 10px !important;
      text-align: center !important;
      padding: 10px 15px !important;
    }

    #leaderboard-rows .team-composition {
      justify-content: center !important;
    }

    #leaderboard-rows .rank,
    #leaderboard-rows .duration,
    #leaderboard-rows .mythic-rating,
    #leaderboard-rows .completed-time {
      font-size: 1.1em !important;
      margin: 5px 0 !important;
    }
  }

  /* Team/Player leaderboard styles */
  #team-rows {
    display: table;
    width: 100%;
    table-layout: fixed;
    border-spacing: 0;
    border-collapse: collapse;
  }

  #team-rows .leaderboard-row,
  #team-rows .chart-item-header {
    display: table-row !important;
    border-bottom: 1px solid #4a4a4a !important;
    background-color: #32302f !important;
    transition: background-color 0.2s ease !important;
  }

  #team-rows .leaderboard-row:hover,
  #team-rows .chart-item-header:hover {
    background-color: rgba(255, 215, 0, 0.05) !important;
  }

  /* Expandable chart item styles */
  .chart-item-wrapper {
    border-radius: 6px;
    transition: background-color 0.2s ease;
  }

  .chart-item-header {
    cursor: pointer;
    padding: 8px 12px;
    border-radius: 6px;
    transition: background-color 0.2s ease;
  }

  .chart-item-header:hover {
    background-color: rgba(255, 255, 255, 0.05);
  }

  .chart-item-expanded .chart-item-header {
    background-color: rgba(255, 255, 255, 0.08);
  }

  .chart-expand-icon {
    margin-left: 8px;
    font-size: 0.8em;
    color: var(--text-muted);
    transition: transform 0.2s ease;
    user-select: none;
  }

  .chart-item-expanded .chart-expand-icon {
    transform: rotate(90deg);
  }

  .chart-dropdown {
    margin-top: 12px;
    padding: 16px;
    background-color: var(--bg-selection);
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    display: none;
  }

  .chart-item-expanded .chart-dropdown {
    display: block;
    animation: dropdown-expand 0.2s ease-out;
  }

  @keyframes dropdown-expand {
    from {
      opacity: 0;
      transform: translateY(-8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<script
  is:inline
  define:vars={{
    baseUrl,
    initialLeaderboardType,
    initialRegion,
    initialRealm,
    initialDungeon,
    DATA_MAP,
  }}
>
  // DATA_MAP is now passed from Astro via define:vars
  const dungeonNames = {
    "2": "Temple of the Jade Serpent",
    "56": "Stormstout Brewery",
    "57": "Gate of the Setting Sun",
    "58": "Shado-Pan Monastery",
    "59": "Siege of Niuzao Temple",
    "60": "Mogu'shan Palace",
    "76": "Scholomance",
    "77": "Scarlet Halls",
    "78": "Scarlet Monastery",
  };

  function dungeonNameToSlug(dungeonName) {
    return dungeonName.toLowerCase().replace(/[^a-z0-9]/g, "-");
  }

  function formatDuration(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return minutes + ":" + seconds.toString().padStart(2, "0");
  }

  function formatTimestamp(timestamp) {
    return new Date(timestamp).toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  }

  function createLeaderboardRow(group) {
    console.log("Creating row for group:", group);

    const row = document.createElement("div");
    row.className = "leaderboard-row";

    // Get current realm selection to check for cross-realm players
    const currentRegion = document.getElementById("region").value;
    const currentRealm = document.getElementById("realm").value;
    const isIndividualRealmView =
      currentRegion &&
      currentRealm &&
      currentRealm !== "all" &&
      currentRegion !== "global";

    let teamHtml = "";
    group.members.forEach((member) => {
      // Handle both old format (member.specialization.id) and optimized format (member.spec_id)
      const specId = member.spec_id || member.specialization?.id;
      const spec = specId
        ? window.WoW.getSpecInfo(specId)
        : {
            role: "dps",
            class: "Unknown",
            spec: "Unknown",
          };
      const iconUrl = window.WoW.getSpecIcon(spec.class, spec.spec);
      const iconHtml = iconUrl
        ? '<img src="' +
          iconUrl +
          '" alt="' +
          spec.spec +
          " " +
          spec.class +
          '" style="width: 16px; height: 16px; border-radius: 2px; margin-right: 4px; vertical-align: middle; flex-shrink: 0;">'
        : "";

      // Handle both old format (member.profile.name) and optimized format (member.name)
      let playerName = member.name || member.profile?.name;

      // Check if player is from a different realm (for individual realm views only)
      const memberRealmSlug = member.realm_slug || member.profile?.realm?.slug;
      if (
        isIndividualRealmView &&
        memberRealmSlug &&
        memberRealmSlug !== currentRealm
      ) {
        playerName +=
          '<span style="color: #ff6b6b; font-weight: bold; margin-left: 2px;">*</span>';
      }

      teamHtml +=
        '<span style="display: inline-flex; align-items: center; margin-right: 8px; gap: 4px;">' +
        iconHtml +
        '<span style="color: ' +
        window.WoW.getClassColor(spec.class) +
        '; font-weight: 600; font-size: 0.9em;">' +
        playerName +
        "</span>" +
        "</span>";
    });

    row.innerHTML =
      '<div style="display: table-cell; padding: 15px 10px; vertical-align: middle; font-size: 1.2em; font-weight: bold; color: #d8a657; text-align: center; width: 80px;">#' +
      group.ranking +
      "</div>" +
      "<div style=\"display: table-cell; padding: 15px 10px; vertical-align: middle; font-family: 'Courier New', monospace; font-weight: bold; color: #ffffff; text-align: right; width: 120px;\">" +
      formatDuration(group.duration) +
      "</div>" +
      '<div style="display: table-cell; padding: 15px 10px; vertical-align: middle;">' +
      teamHtml +
      "</div>" +
      '<div style="display: table-cell; padding: 15px 10px; vertical-align: middle; color: #aaaaaa; font-size: 0.9em; text-align: center; width: 140px;">' +
      formatTimestamp(group.completed_timestamp) +
      "</div>";

    // Apply table-row styles
    row.style.cssText =
      "display: table-row !important; border-bottom: 1px solid #4a4a4a !important; background-color: #32302f; transition: background-color 0.2s ease;";

    // Add hover effect
    row.addEventListener("mouseenter", () => {
      row.style.backgroundColor = "rgba(255, 215, 0, 0.05)";
    });
    row.addEventListener("mouseleave", () => {
      row.style.backgroundColor = "#32302f";
    });

    console.log("Row created:", row);
    return row;
  }

  function getTeamSignature(members) {
    // Create a unique signature for the team based on sorted player IDs
    const playerIds = members
      .map((member) => {
        // Handle both old format (member.profile.id) and optimized format (member.id)
        return member.id || member.profile?.id || 0;
      })
      .sort((a, b) => a - b); // Sort IDs to ensure consistent signature

    return playerIds.join("-");
  }

  function filterUniqueTeams(leaderboardData) {
    const teamFilter = document.getElementById("team-filter");
    if (!teamFilter.checked) {
      return leaderboardData; // Return original data if filter is not active
    }

    const uniqueTeams = new Map();

    leaderboardData.forEach((run) => {
      const teamSignature = getTeamSignature(run.members);

      // Keep only the fastest time for each unique team
      if (
        !uniqueTeams.has(teamSignature) ||
        run.duration < uniqueTeams.get(teamSignature).duration
      ) {
        uniqueTeams.set(teamSignature, run);
      }
    });

    // Convert back to array and sort by duration
    return Array.from(uniqueTeams.values()).sort(
      (a, b) => a.duration - b.duration,
    );
  }

  // Store original data for re-filtering
  let originalLeaderboardData = null;

  function displayLeaderboard(data) {
    console.log("Displaying leaderboard data:", data);

    // Handle both old format (individual realm) and new format (aggregated)
    let leaderboardData = data.leaderboard || data.leading_groups;

    // Check if we have no data
    if (!leaderboardData || leaderboardData.length === 0) {
      showNoData();
      return;
    }

    // Store original data for re-filtering
    originalLeaderboardData = [...leaderboardData];

    // Apply team filtering if enabled
    leaderboardData = filterUniqueTeams(leaderboardData);

    // Handle dungeon name from both formats
    let dungeonName;
    if (data.dungeon_name) {
      // New aggregated format
      dungeonName = data.dungeon_name;
    } else if (data.map) {
      // Old individual realm format
      dungeonName =
        typeof data.map.name === "object"
          ? data.map.name.en_US || data.map.name
          : data.map.name;
    }
    document.getElementById("dungeon-name").textContent =
      dungeonName || "Unknown Dungeon";

    // Handle period info (only available in individual realm format)
    if (data.period) {
      document.getElementById("period").textContent = data.period;
      document.getElementById("period-start").textContent = formatTimestamp(
        data.period_start_timestamp,
      );
      document.getElementById("period-end").textContent = formatTimestamp(
        data.period_end_timestamp,
      );
    } else {
      document.getElementById("period").textContent = "Multiple Periods";
      document.getElementById("period-start").textContent = "-";
      document.getElementById("period-end").textContent = "-";
    }

    // Handle realm name display
    const currentRegion = document.getElementById("region").value;
    const currentRealm = document.getElementById("realm").value;
    let realmDisplayName;

    if (currentRegion === "global") {
      realmDisplayName = "All Regions";
    } else if (currentRealm === "all") {
      realmDisplayName = "All " + currentRegion.toUpperCase() + " Realms";
    } else {
      const regionData = DATA_MAP[currentRegion];
      realmDisplayName = regionData?.realms?.[currentRealm] || currentRealm;
    }
    document.getElementById("realm-name").textContent = realmDisplayName;

    // Show/hide cross-realm indicator explanation
    const crossRealmNote = document.getElementById("cross-realm-note");
    const isIndividualRealmView =
      currentRegion &&
      currentRealm &&
      currentRealm !== "all" &&
      currentRegion !== "global";
    if (crossRealmNote) {
      crossRealmNote.style.display = isIndividualRealmView ? "block" : "none";
    }

    const rowsContainer = document.getElementById("leaderboard-rows");
    rowsContainer.innerHTML = "";

    console.log("Creating rows for", leaderboardData.length, "groups");
    leaderboardData.forEach((group, index) => {
      console.log("Creating row for group", index + 1);
      // Update ranking for filtered display
      const displayGroup = { ...group, ranking: index + 1 };
      const row = createLeaderboardRow(displayGroup);
      rowsContainer.appendChild(row);
    });

    document.getElementById("loading").classList.add("hidden");
    document.getElementById("error").classList.add("hidden");
    document.getElementById("no-data").classList.add("hidden");
    document.getElementById("content").classList.remove("content-loading");
    document.getElementById("content").classList.remove("hidden");

    console.log("Leaderboard displayed successfully");
  }

  function refreshLeaderboardDisplay() {
    if (!originalLeaderboardData) {
      console.log("No original data to refresh from");
      return;
    }

    // Apply team filtering to original data
    let leaderboardData = filterUniqueTeams(originalLeaderboardData);

    // Update the display with filtered data
    const rowsContainer = document.getElementById("leaderboard-rows");
    rowsContainer.innerHTML = "";

    console.log("Refreshing display with", leaderboardData.length, "groups");
    leaderboardData.forEach((group, index) => {
      // Update ranking for filtered display
      const displayGroup = { ...group, ranking: index + 1 };
      const row = createLeaderboardRow(displayGroup);
      rowsContainer.appendChild(row);
    });
  }

  function showNoData() {
    document.getElementById("loading").classList.add("hidden");
    document.getElementById("error").classList.add("hidden");
    document.getElementById("no-data").classList.remove("hidden");
    document.getElementById("content").classList.add("hidden");
  }

  function showError(message) {
    const errorDiv = document.getElementById("error");
    const loadingMessage = errorDiv.querySelector(".loading-message");
    if (loadingMessage) {
      loadingMessage.textContent = message;
    } else {
      // Fallback if LoadingState structure isn't found
      errorDiv.innerHTML =
        '<div class="loading-state error"><p class="loading-message">' +
        message +
        "</p></div>";
    }
    errorDiv.classList.remove("hidden");
    document.getElementById("loading").classList.add("hidden");
    document.getElementById("no-data").classList.add("hidden");
    document.getElementById("content").classList.add("hidden");
  }

  function showLoading() {
    document.getElementById("loading").classList.remove("hidden");
    document.getElementById("error").classList.add("hidden");
    document.getElementById("no-data").classList.add("hidden");
    document.getElementById("content").classList.add("content-loading");
  }

  function updateRealmOptions() {
    const region = document.getElementById("region").value;
    const realmSelect = document.getElementById("realm");

    console.log("=== updateRealmOptions START ===");
    console.log("Region:", region);

    // Clear existing options
    realmSelect.innerHTML = "";

    if (!region) {
      // No region selected
      const option = document.createElement("option");
      option.value = "";
      option.textContent = "Select Region First";
      option.selected = true;
      realmSelect.appendChild(option);
      realmSelect.disabled = true;
      console.log("No region selected, showing placeholder");
      return;
    }

    if (region === "global") {
      // Global selected - disable realm selection and show "N/A"
      const option = document.createElement("option");
      option.value = "global";
      option.textContent = "N/A (Global View)";
      option.selected = true;
      realmSelect.appendChild(option);
      realmSelect.disabled = true;
      console.log("Global region selected, disabled realm options");
      return;
    }

    // Enable realm selection for regional selections
    realmSelect.disabled = false;

    // Add "All Realms" option for regional view
    const allRealmsOption = document.createElement("option");
    allRealmsOption.value = "all";
    allRealmsOption.textContent = "All " + region.toUpperCase() + " Realms";
    realmSelect.appendChild(allRealmsOption);

    // Add default option
    const defaultOption = document.createElement("option");
    defaultOption.value = "";
    defaultOption.textContent = "Select Realm";
    defaultOption.selected = true;
    realmSelect.appendChild(defaultOption);

    // Add individual realms for selected region
    const regionData = DATA_MAP[region];
    if (regionData && regionData.realms) {
      Object.entries(regionData.realms).forEach(([slug, name]) => {
        const option = document.createElement("option");
        option.value = slug;
        option.textContent = name;
        realmSelect.appendChild(option);
      });
    }

    console.log("=== updateRealmOptions END ===");
  }

  function getDataFileName() {
    const region = document.getElementById("region").value;
    const realm = document.getElementById("realm").value;
    const dungeon = document.getElementById("dungeon").value;

    console.log("Getting data filename with:", { region, realm, dungeon });
    console.log("Dungeon name lookup:", dungeonNames[dungeon]);

    const dungeonSlug = dungeonNameToSlug(dungeonNames[dungeon]);

    let fileName;

    if (region === "global") {
      // Global leaderboard path
      fileName = "leaderboards/global/" + dungeonSlug + "/leaderboard.json";
    } else if (realm === "all") {
      // Regional aggregated leaderboard path
      fileName =
        "leaderboards/regional/" +
        region +
        "/" +
        dungeonSlug +
        "/leaderboard.json";
    } else {
      // Individual realm leaderboard path (existing system)
      fileName =
        "challenge-mode/" +
        region +
        "/" +
        realm +
        "/" +
        dungeonSlug +
        "/" +
        realm +
        "-" +
        dungeonSlug +
        "-leaderboard.json";
    }

    console.log("Generated filename:", fileName);
    return fileName;
  }

  function canLoadLeaderboard() {
    const region = document.getElementById("region").value;
    const realm = document.getElementById("realm").value;
    const dungeon = document.getElementById("dungeon").value;

    // For global, we only need region and dungeon
    if (region === "global") {
      return region && dungeon;
    }

    // For regional/individual realms, we need all three
    return region && realm && dungeon;
  }

  async function loadLeaderboard() {
    // Only load if all selections are made
    if (!canLoadLeaderboard()) {
      console.log("Cannot load leaderboard - missing selections");
      return;
    }

    showLoading();

    try {
      const fileName = getDataFileName();
      console.log("Loading file:", fileName);
      // Use absolute path for GitHub Pages compatibility
      const fullUrl = "/data/" + fileName;
      console.log("Full fetch URL:", fullUrl);
      const response = await fetch(fullUrl);

      if (!response.ok) {
        throw new Error(
          "Failed to load leaderboard data: " + response.statusText,
        );
      }

      const data = await response.json();
      console.log("Data loaded:", data);
      displayLeaderboard(data);
    } catch (error) {
      console.error("Error loading leaderboard:", error);
      showError("Error loading leaderboard data: " + error.message);
    }
  }

  function updateURL() {
    const region = document.getElementById("region").value;
    const realm = document.getElementById("realm").value;
    const dungeon = document.getElementById("dungeon").value;

    // Don't update URL if we can't load leaderboard
    if (!canLoadLeaderboard()) {
      return;
    }

    const dungeonName = dungeonNameToSlug(dungeonNames[dungeon]);

    let newURL;

    if (region === "global") {
      // Global leaderboard URL: /challenge-mode/global/dungeon
      newURL = "/challenge-mode/global/" + dungeonName;
    } else if (realm === "all") {
      // Regional leaderboard URL: /challenge-mode/region/all/dungeon
      newURL = "/challenge-mode/" + region + "/all/" + dungeonName;
    } else {
      // Individual realm URL: /challenge-mode/region/realm/dungeon
      newURL = "/challenge-mode/" + region + "/" + realm + "/" + dungeonName;
    }

    window.history.pushState({}, "", newURL);
  }

  // Event listeners
  document.addEventListener("DOMContentLoaded", () => {
    // Initialize realm options
    updateRealmOptions();

    // Set initial values if provided (for slug routing)
    if (initialRegion) {
      document.getElementById("region").value = initialRegion;
      updateRealmOptions();
      if (initialRealm) {
        document.getElementById("realm").value = initialRealm;
      }
      if (initialDungeon) {
        document.getElementById("dungeon").value = initialDungeon;
      }
      // Load initial data if we have a complete selection
      if (canLoadLeaderboard()) {
        loadLeaderboard();
      }
    }

    // Bind change events
    document.getElementById("region").addEventListener("change", () => {
      console.log(
        "Region changed to:",
        document.getElementById("region").value,
      );
      updateRealmOptions();
      // Reset realm selection when region changes
      document.getElementById("realm").value = "";
      // Enable realm select
      document.getElementById("realm").disabled = false;
      updateURL();
      loadLeaderboard();
    });
    document.getElementById("realm").addEventListener("change", () => {
      console.log("Realm changed to:", document.getElementById("realm").value);
      updateURL();
      loadLeaderboard();
    });
    document.getElementById("dungeon").addEventListener("change", () => {
      console.log(
        "Dungeon changed to:",
        document.getElementById("dungeon").value,
      );
      updateURL();
      loadLeaderboard();
    });

    // Team filter toggle event listener
    document.getElementById("team-filter").addEventListener("change", () => {
      console.log(
        "Team filter changed to:",
        document.getElementById("team-filter").checked,
      );
      refreshLeaderboardDisplay();
    });

    // Leaderboard Type change handler
    document
      .getElementById("leaderboard-type")
      .addEventListener("change", () => {
        const leaderboardType =
          document.getElementById("leaderboard-type").value;
        console.log("Leaderboard type changed to:", leaderboardType);
        handleLeaderboardTypeChange(leaderboardType);
      });

    // Initialize with the correct leaderboard type
    if (initialLeaderboardType) {
      document.getElementById("leaderboard-type").value =
        initialLeaderboardType;
      handleLeaderboardTypeChange(initialLeaderboardType);
    }
  });

  // Handle leaderboard type switching
  function handleLeaderboardTypeChange(leaderboardType) {
    const dungeonSelectors = document.getElementById("dungeon-selectors");
    const dungeonLeaderboard = document.getElementById("dungeon-leaderboard");
    const teamPlayerLeaderboard = document.getElementById(
      "team-player-leaderboard",
    );
    const teamsCallout = document.getElementById("teams-callout");

    // Update URL
    updateLeaderboardURL(leaderboardType);

    // Show/hide teams callout
    if (leaderboardType === "teams") {
      teamsCallout.style.display = "block";
    } else {
      teamsCallout.style.display = "none";
    }

    if (leaderboardType === "dungeon") {
      // Show dungeon selectors and dungeon leaderboard
      dungeonSelectors.style.display = "block";
      dungeonLeaderboard.style.display = "block";
      teamPlayerLeaderboard.style.display = "none";

      // Load existing dungeon data if selections are made
      if (
        document.getElementById("region").value &&
        document.getElementById("realm").value &&
        document.getElementById("dungeon").value
      ) {
        loadLeaderboard();
      }
    } else {
      // Hide dungeon selectors and show team/player leaderboard
      dungeonSelectors.style.display = "none";
      dungeonLeaderboard.style.display = "none";
      teamPlayerLeaderboard.style.display = "block";

      // Load team or player data
      loadTeamPlayerLeaderboard(leaderboardType);
    }
  }

  // Update URL based on leaderboard type
  function updateLeaderboardURL(leaderboardType) {
    let newURL;
    if (leaderboardType === "players") {
      newURL = "/challenge-mode/players";
    } else if (leaderboardType === "teams") {
      newURL = "/challenge-mode/teams";
    } else {
      newURL = "/challenge-mode/";
    }

    if (window.location.pathname !== newURL) {
      window.history.pushState({}, "", newURL);
    }
  }

  // Load team/player leaderboard data
  async function loadTeamPlayerLeaderboard(mode) {
    showLoading();

    try {
      const dataPath =
        mode === "players" ? "player-leaderboards" : "team-leaderboards";
      const fileName = "best-overall.json";
      const fullUrl = `${baseUrl}data/${dataPath}/${fileName}`;
      console.log(`Loading ${mode} leaderboard from:`, fullUrl);

      const response = await fetch(fullUrl);
      if (!response.ok) {
        throw new Error(
          `Failed to load ${mode} leaderboard data: ` + response.statusText,
        );
      }

      const data = await response.json();
      console.log(`${mode} leaderboard data loaded:`, data);
      displayTeamPlayerLeaderboard(data, mode);
    } catch (error) {
      console.error(`Error loading ${mode} leaderboard:`, error);
      showError(`Error loading ${mode} leaderboard data: ` + error.message);
    }
  }

  // Display team/player leaderboard
  function displayTeamPlayerLeaderboard(data, mode) {
    console.log(`Displaying ${mode} leaderboard data:`, data);

    if (!data.leaderboard || data.leaderboard.length === 0) {
      showNoData();
      return;
    }

    // Update info display - use Challenge Mode element IDs
    const dungeonNameElement = document.getElementById("dungeon-name");
    if (dungeonNameElement) {
      dungeonNameElement.textContent = data.title;
    }

    // Update period info to show generated timestamp
    const periodElement = document.getElementById("period");
    if (periodElement) {
      periodElement.textContent = data.generated_timestamp
        ? formatTimestamp(data.generated_timestamp)
        : "Unknown";
    }

    const rowsContainer = document.getElementById("team-rows");
    rowsContainer.innerHTML = "";

    data.leaderboard.forEach((item, index) => {
      item.ranking = index + 1;
      const wrapper =
        mode === "players" ? createPlayerRow(item) : createTeamRow(item);
      rowsContainer.appendChild(wrapper);
    });

    hideLoading();
  }

  // Utility functions
  function formatDuration(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const ms = milliseconds % 1000;
    return (
      minutes +
      ":" +
      seconds.toString().padStart(2, "0") +
      "." +
      ms.toString().padStart(3, "0")
    );
  }

  function formatTimestamp(timestamp) {
    return new Date(timestamp).toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  }

  function hideLoading() {
    document.getElementById("loading").classList.add("hidden");
    document.getElementById("error").classList.add("hidden");
    document.getElementById("no-data").classList.add("hidden");
    document.getElementById("content").classList.remove("content-loading");
    document.getElementById("content").classList.remove("hidden");
  }

  // Global function for chart item expansion
  window.toggleChartItem = (element) => {
    const wrapper = element.closest(".chart-item-wrapper");
    if (!wrapper) return;

    const isExpanded = wrapper.classList.contains("chart-item-expanded");

    // Close all other expanded items
    document.querySelectorAll(".chart-item-expanded").forEach((item) => {
      if (item !== wrapper) {
        item.classList.remove("chart-item-expanded");
      }
    });

    // Toggle current item
    wrapper.classList.toggle("chart-item-expanded", !isExpanded);
  };

  function getSpecColor(specId) {
    // WoW class colors based on spec_id
    const specColors = {
      // Death Knight
      250: "#C41F3B",
      251: "#C41F3B",
      252: "#C41F3B",
      // Druid
      102: "#FF7D0A",
      103: "#FF7D0A",
      104: "#FF7D0A",
      105: "#FF7D0A",
      // Hunter
      253: "#ABD473",
      254: "#ABD473",
      255: "#ABD473",
      // Mage
      62: "#69CCF0",
      63: "#69CCF0",
      64: "#69CCF0",
      // Monk
      268: "#00FF96",
      269: "#00FF96",
      270: "#00FF96",
      // Paladin
      65: "#F58CBA",
      66: "#F58CBA",
      70: "#F58CBA",
      // Priest
      256: "#FFFFFF",
      257: "#FFFFFF",
      258: "#FFFFFF",
      // Rogue
      259: "#FFF569",
      260: "#FFF569",
      261: "#FFF569",
      // Shaman
      262: "#0070DE",
      263: "#0070DE",
      264: "#0070DE",
      // Warlock
      265: "#9482C9",
      266: "#9482C9",
      267: "#9482C9",
      // Warrior
      71: "#C79C6E",
      72: "#C79C6E",
      73: "#C79C6E",
    };
    return specColors[specId] || "#FFFFFF";
  }

  function createPlayerRow(player) {
    const wrapper = document.createElement("div");
    wrapper.className = "chart-item-wrapper";

    // Get player spec info for display
    const spec = player.main_spec_id
      ? window.WoW.getSpecInfo(player.main_spec_id)
      : null;
    const iconUrl = spec ? window.WoW.getSpecIcon(spec.class, spec.spec) : null;
    const classColor = spec ? window.WoW.getClassColor(spec.class) : "#FFFFFF";

    const iconHtml = iconUrl
      ? `<img src="${iconUrl}" alt="${spec.spec} ${spec.class}" style="width: 20px; height: 20px; border-radius: 2px; margin-right: 8px; vertical-align: middle; flex-shrink: 0;">`
      : "";

    // Create the player details content
    const playerDetails = createPlayerDetailsContent(player);

    wrapper.innerHTML = `
      <div class="leaderboard-row chart-item-header" onclick="toggleChartItem(this.parentElement)" style="display: table-row !important; border-bottom: 1px solid #4a4a4a !important; transition: background-color 0.2s ease !important; cursor: pointer;">
        <div style="display: table-cell; padding: 15px 10px; vertical-align: middle; font-size: 1.2em; font-weight: bold; color: #d8a657; text-align: center; width: 80px;">#${player.ranking}</div>
        <div style="display: table-cell; padding: 15px 10px; vertical-align: middle; font-family: 'Courier New', monospace; font-weight: bold; color: #ffffff; text-align: right; width: 120px; white-space: nowrap;">${formatDuration(player.combined_best_time)}</div>
        <div style="display: table-cell; padding: 15px 10px; vertical-align: middle; width: 100%;">
          <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
            <div style="display: flex; align-items: center;">
              <span class="chart-expand-icon" style="margin-right: 8px;">▶</span>
              ${iconHtml}
              <span style="color: ${classColor}; font-weight: 600; font-size: 1.1em;">${player.name}</span>
            </div>
            <span style="color: var(--text-secondary); font-size: 0.9em;">@${player.realm_slug}</span>
          </div>
        </div>
      </div>
      <div class="chart-dropdown">
        ${playerDetails}
      </div>
    `;

    return wrapper;
  }

  function createTeamRow(team) {
    const wrapper = document.createElement("div");
    wrapper.className = "chart-item-wrapper";

    // Create extended roster display with spec colors
    const extendedRoster = team.extended_roster
      .map((member) => {
        const specColor = member.spec_id
          ? getSpecColor(member.spec_id)
          : "#FFFFFF";
        return `<span style="display: inline-flex; align-items: center; margin-right: 8px; gap: 4px;">
        <span style="color: ${specColor}; font-weight: 600; font-size: 0.9em;">${member.name}</span>
        <span style="color: var(--text-secondary); font-size: 0.8em;">@${member.realm_slug}</span>
      </span>`;
      })
      .join("");

    // Create the team details content
    const teamDetails = createTeamDetailsContent(team);

    wrapper.innerHTML = `
      <div class="leaderboard-row chart-item-header" onclick="toggleChartItem(this.parentElement)" style="display: table-row !important; border-bottom: 1px solid #4a4a4a !important; transition: background-color 0.2s ease !important; cursor: pointer;">
        <div style="display: table-cell; padding: 15px 10px; vertical-align: middle; font-size: 1.2em; font-weight: bold; color: #d8a657; text-align: center; width: 80px;">#${team.ranking}</div>
        <div style="display: table-cell; padding: 15px 10px; vertical-align: middle; font-family: 'Courier New', monospace; font-weight: bold; color: #ffffff; text-align: right; width: 120px;">${formatDuration(team.combined_best_time)}</div>
        <div style="display: table-cell; padding: 15px 10px; vertical-align: middle; display: flex; align-items: center; overflow: hidden;">
          <span class="chart-expand-icon" style="margin-right: 8px; flex-shrink: 0;">▶</span>
          <div style="display: flex; flex-wrap: wrap; align-items: center; overflow: hidden; min-width: 0;">${extendedRoster}</div>
        </div>
      </div>
      <div class="chart-dropdown">
        ${teamDetails}
      </div>
    `;

    return wrapper;
  }

  function createPlayerDetailsContent(player) {
    // Create dungeon run entries styled like Challenge Mode leaderboard rows
    const dungeonEntries = Object.entries(player.best_runs_per_dungeon || {})
      .map(([_dungeonSlug, run]) => {
        // Create team composition with spec icons using all_members data
        const teamComposition = (run.all_members || [])
          .map((member) => {
            const spec = member.spec_id
              ? window.WoW.getSpecInfo(member.spec_id)
              : null;
            const iconUrl = spec
              ? window.WoW.getSpecIcon(spec.class, spec.spec)
              : null;
            const classColor = spec
              ? window.WoW.getClassColor(spec.class)
              : "#FFFFFF";

            const iconHtml = iconUrl
              ? `<img src="${iconUrl}" alt="${spec.spec} ${spec.class}" style="width: 16px; height: 16px; border-radius: 2px; margin-right: 4px; vertical-align: middle; flex-shrink: 0;">`
              : "";

            return `<span style="display: inline-flex; align-items: center; margin-right: 8px; gap: 4px;">
          ${iconHtml}
          <span style="color: ${classColor}; font-weight: 600; font-size: 0.9em;">${member.name}@${member.realm_slug}</span>
        </span>`;
          })
          .join("");

        return `
        <div style="display: grid; grid-template-columns: 80px 120px 2fr 100px 140px; gap: 20px; align-items: center; padding: 15px 20px; border-bottom: 1px solid #3a3a3a; min-height: 60px;">
          <div style="font-size: 1.2em; font-weight: bold; color: #d8a657; text-align: center;">${run.ranking === "~" ? "~" : "#" + run.ranking}</div>
          <div style="font-family: 'Courier New', monospace; font-weight: bold; color: #ffffff; text-align: right;">${formatDuration(run.duration)}</div>
          <div style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: flex-start; align-items: center;">${teamComposition}</div>
          <div style="color: var(--text-primary); text-align: center; font-weight: 600;">${run.dungeon_name}</div>
          <div style="color: #aaaaaa; font-size: 0.9em; text-align: center;">${formatTimestamp(run.completed_timestamp)}</div>
        </div>
      `;
      })
      .join("");

    return `
      <div>
        <h4 style="color: var(--highlight-color); margin-bottom: 10px;">Best Times Per Dungeon</h4>
        <div style="border-radius: 6px; overflow: hidden; border: 1px solid #4a4a4a;">
          <div style="display: grid; grid-template-columns: 80px 120px 2fr 100px 140px; gap: 20px; padding: 15px 20px; background-color: rgba(255, 255, 255, 0.03); border-bottom: 1px solid #4a4a4a; font-weight: 600; color: var(--text-secondary); font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">
            <div>Global Rank</div>
            <div style="text-align: right;">Time</div>
            <div>Team Composition</div>
            <div style="text-align: center;">Dungeon</div>
            <div style="text-align: center;">Date</div>
          </div>
          ${dungeonEntries}
        </div>
      </div>
    `;
  }

  function createMemberLookup(team) {
    // Create a lookup map from member names to their full member data with spec_id
    const memberLookup = {};

    // Process all runs to build a comprehensive lookup
    team.all_runs.forEach((run) => {
      run.members.forEach((member) => {
        if (!memberLookup[member.name]) {
          memberLookup[member.name] = {
            name: member.name,
            realm_slug: member.realm_slug,
            spec_id: member.spec_id,
            id: member.id,
          };
        }
      });
    });

    return memberLookup;
  }

  function createTeamComposition(memberNames, memberLookup) {
    // Create styled team composition similar to Challenge Mode
    return memberNames
      .map((memberName) => {
        const member = memberLookup[memberName];
        if (!member) {
          // Fallback if member not found in lookup
          return `<span style="color: var(--text-primary); margin-right: 8px;">${memberName}</span>`;
        }

        const spec = member.spec_id
          ? window.WoW.getSpecInfo(member.spec_id)
          : null;
        const iconUrl = spec
          ? window.WoW.getSpecIcon(spec.class, spec.spec)
          : null;
        const classColor = spec
          ? window.WoW.getClassColor(spec.class)
          : "#FFFFFF";

        const iconHtml = iconUrl
          ? `<img src="${iconUrl}" alt="${spec.spec} ${spec.class}" style="width: 16px; height: 16px; border-radius: 2px; margin-right: 4px; vertical-align: middle; flex-shrink: 0;">`
          : "";

        return `<span style="display: inline-flex; align-items: center; margin-right: 8px; gap: 4px;">
        ${iconHtml}
        <span style="color: ${classColor}; font-weight: 600; font-size: 0.9em;">${member.name}@${member.realm_slug}</span>
      </span>`;
      })
      .join("");
  }

  function createTeamDetailsContent(team) {
    // Create member lookup for this team
    const memberLookup = createMemberLookup(team);

    // Create core members display with Challenge Mode styling
    const coreMembers = team.core_members
      .map((member) => {
        const spec = member.spec_id
          ? window.WoW.getSpecInfo(member.spec_id)
          : null;
        const iconUrl = spec
          ? window.WoW.getSpecIcon(spec.class, spec.spec)
          : null;
        const classColor = spec
          ? window.WoW.getClassColor(spec.class)
          : "#FFFFFF";

        const iconHtml = iconUrl
          ? `<img src="${iconUrl}" alt="${spec.spec} ${spec.class}" style="width: 16px; height: 16px; border-radius: 2px; margin-right: 4px; vertical-align: middle; flex-shrink: 0;">`
          : "";

        return `<span style="display: inline-flex; align-items: center; margin-right: 15px; gap: 4px;">
        ${iconHtml}
        <span style="color: ${classColor}; font-weight: 600; font-size: 0.9em;">${member.name}@${member.realm_slug}</span>
      </span>`;
      })
      .join("");

    // Create dungeon run entries styled like Challenge Mode leaderboard rows
    const dungeonEntries = Object.entries(team.best_runs_per_dungeon || {})
      .map(([_dungeonSlug, run]) => {
        const teamComposition = createTeamComposition(
          run.members,
          memberLookup,
        );

        return `
        <div style="display: grid; grid-template-columns: 80px 120px 2fr 100px 140px; gap: 20px; align-items: center; padding: 15px 20px; border-bottom: 1px solid #3a3a3a; min-height: 60px;">
          <div style="font-size: 1.2em; font-weight: bold; color: #d8a657; text-align: center;">#${run.ranking}</div>
          <div style="font-family: 'Courier New', monospace; font-weight: bold; color: #ffffff; text-align: right;">${formatDuration(run.duration)}</div>
          <div style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: flex-start; align-items: center;">${teamComposition}</div>
          <div style="color: var(--text-primary); text-align: center; font-weight: 600;">${run.dungeon_name}</div>
          <div style="color: #aaaaaa; font-size: 0.9em; text-align: center;">${formatTimestamp(run.completed_timestamp)}</div>
        </div>
      `;
      })
      .join("");

    return `
      <div style="margin-bottom: 20px;">
        <h4 style="color: var(--highlight-color); margin-bottom: 10px;">Identified Core Team </h4>
        <div style="display: flex; flex-wrap: wrap; align-items: center;">${coreMembers}</div>
      </div>
      
      <div>
        <h4 style="color: var(--highlight-color); margin-bottom: 10px;">Best Times Per Dungeon</h4>
        <div style="border-radius: 6px; overflow: hidden; border: 1px solid #4a4a4a;">
          <div style="display: grid; grid-template-columns: 80px 120px 2fr 100px 140px; gap: 20px; padding: 15px 20px; background-color: rgba(255, 255, 255, 0.03); border-bottom: 1px solid #4a4a4a; font-weight: 600; color: var(--text-secondary); font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">
            <div>Rank</div>
            <div style="text-align: right;">Time</div>
            <div>Team Composition</div>
            <div style="text-align: center;">Dungeon</div>
            <div style="text-align: center;">Date</div>
          </div>
          ${dungeonEntries}
        </div>
      </div>
    `;
  }
</script>
