---
import type { LeaderboardData, ChallengeRun } from "../../lib/types";
import LoadingState from "../LoadingState.astro";
import { formatDurationMMSS, buildPlayerProfileURL } from "../../lib/utils.ts";

export interface Props {
  initialData?: LeaderboardData;
  region: string;
  realm: string;
  dungeon: string;
  dungeonName?: string;
  class?: string;
}

const {
  initialData,
  region,
  realm,
  dungeon,
  dungeonName: _dungeonName = "Unknown Dungeon",
  class: className,
} = Astro.props;

const runs = initialData?.leading_groups || [];
const pagination = initialData?.pagination;
---

<div
  class={`leaderboard-container card-container ${className || ""}`.trim()}
  data-region={region}
  data-realm={realm}
  data-dungeon={dungeon}
>
  <!-- loading State (hidden by default, shown during API calls) -->
  <div id="loading-container" style="display: none;">
    <LoadingState message="Loading leaderboard..." />
  </div>

  <!-- error State (hidden by default) -->
  <div id="error-container" style="display: none;">
    <LoadingState type="error" message="" />
  </div>

  <!-- leaderboard content -->
  <div id="leaderboard-content">
    {
      runs.length > 0 ? (
        <div id="leaderboard-rows" class="leaderboard-table">
          {runs.map((run: ChallengeRun, index: number) => {
            const rank = pagination?.currentPage
              ? (pagination.currentPage - 1) * 25 + index + 1
              : index + 1;
            const duration = formatDurationMMSS(run.duration);
            const timestamp = new Date(
              run.completed_timestamp,
            ).toLocaleDateString();

            return (
              <div class="leaderboard-table-row" data-run-id={run.id}>
                <div class="leaderboard-cell leaderboard-cell--rank">
                  #{rank}
                </div>
                <div class="leaderboard-cell leaderboard-cell--time">
                  {duration}
                </div>
                <div class="leaderboard-cell leaderboard-cell--content">
                  {run.members?.map((member) => (
                    <span style="display: inline-flex; align-items: center; margin-right: 8px; gap: 4px;">
                      <a
                        href={buildPlayerProfileURL(
                          member.region || "us",
                          member.realm_slug,
                          member.name,
                        )}
                        style="color: #FFFFFF; font-weight: 600; font-size: 0.9em; text-decoration: none;"
                      >
                        {member.name}
                      </a>
                    </span>
                  ))}
                </div>
                <div class="leaderboard-cell leaderboard-cell--meta">
                  {timestamp}
                </div>
              </div>
            );
          })}
        </div>
      ) : (
        <div class="empty-state">
          <p>Select a region, realm, and dungeon to view leaderboards.</p>
          <p>Use the filters above to get started.</p>
        </div>
      )
    }
  </div>

  <!-- pagination controls (always present, hidden by default) -->
  <div class="pagination-container" style="display: none;">
    <div class="pagination-info">
      <span></span>
    </div>
    <div class="pagination-buttons">
      <button id="prev-page" class="pagination-btn"> Previous </button>
      <span class="page-info"></span>
      <button id="next-page" class="pagination-btn"> Next </button>
    </div>
  </div>

  <!-- cross-realm note (if applicable) -->
  <div id="cross-realm-note" style="display: none;" class="cross-realm-note">
    <p>
      <span class="warning-icon">*</span> indicates players from other realms. Times
      with 3+ local players represent the true realm record for Feat of Strength
      achievement.
    </p>
  </div>
</div>

<script src="../../client/leaderboard-table.ts"></script>
<script type="module">
  console.debug("[LeaderboardTable.astro] module import requested");
</script>

<!-- legacy inline script removed; now bundled via /src/client/leaderboard-table.ts
    container; region; realm; dungeon; currentPage = 1;

    constructor(container) {
      this.container = container;
      this.region = container.dataset.region || "";
      this.realm = container.dataset.realm || "";
      this.dungeon = container.dataset.dungeon || "";

      this.bindEvents();
    }

    bindEvents() {
      // pagination button events
      const prevBtn = this.container.querySelector("#prev-page");
      const nextBtn = this.container.querySelector("#next-page");

      prevBtn?.addEventListener("click", () => this.previousPage());
      nextBtn?.addEventListener("click", () => this.nextPage());
    }

    async previousPage() {
      if (this.currentPage > 1) {
        this.currentPage--;
        await this.loadLeaderboard();
      }
    }

    async nextPage() {
      this.currentPage++;
      await this.loadLeaderboard();
    }

    async fetchLeaderboardData(region, realm, dungeonId, page = 1) {
      let url;

      if (region === "global") {
        url = `/api/leaderboard/global?dungeonId=${dungeonId}&page=${page}&teamFilter=true`;
      } else if (realm === "all") {
        url = `/api/leaderboard/regional?region=${region}&dungeonId=${dungeonId}&page=${page}&teamFilter=true`;
      } else {
        url = `/api/leaderboard/realm?region=${region}&realmSlug=${realm}&dungeonId=${dungeonId}&page=${page}&teamFilter=true`;
      }

      const response = await fetch(url);
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `API request failed: ${response.status} ${response.statusText} - ${errorText}`,
        );
      }

      return response.json();
    }

    async loadLeaderboard(newRegion, newRealm, newDungeon, targetPage) {
      // update properties if new filters provided
      if (newRegion) this.region = newRegion;
      if (newRealm) this.realm = newRealm;
      if (newDungeon) this.dungeon = newDungeon;

      // reset page when filters change, unless a specific page is requested
      if (newRegion || newRealm || newDungeon) {
        this.currentPage = targetPage || 1;
      } else if (targetPage) {
        // just changing page, not filters
        this.currentPage = targetPage;
      }

      console.log("üìä LeaderboardTable.loadLeaderboard called:", {
        region: this.region,
        realm: this.realm,
        dungeon: this.dungeon,
        targetPage,
        currentPage: this.currentPage,
      });

      try {
        this.showLoading();

        const data = await this.fetchLeaderboardData(
          this.region,
          this.realm,
          parseInt(this.dungeon),
          this.currentPage,
        );

        this.renderLeaderboard(data);
        this.updatePagination(data.pagination);
        this.updateURL();
      } catch (error) {
        this.showError(error);
        console.error("Leaderboard loading error:", error);
      } finally {
        this.hideLoading();
      }
    }

    renderLeaderboard(data) {
      const content = this.container.querySelector("#leaderboard-content");
      if (!content) return;

      if (!data.leading_groups || data.leading_groups.length === 0) {
        content.innerHTML = `
          <div class="empty-state">
            <p>No runs found for this leaderboard.</p>
            <p>Try selecting a different region, realm, or dungeon.</p>
          </div>
        `;
        return;
      }

      // create table structure with shared styling
      content.innerHTML =
        '<div id="leaderboard-rows" class="leaderboard-table"></div>';
      const rowsContainer = content.querySelector("#leaderboard-rows");

      data.leading_groups.forEach((run, index) => {
        const rank = run.ranking || (this.currentPage - 1) * 25 + index + 1;
        const duration = formatDurationMMSS(run.duration);
        const timestamp = formatTimestamp(run.completed_timestamp);

        const currentRegion = this.region;
        const currentRealm = this.realm;
        const isIndividualRealmView =
          currentRegion &&
          currentRealm &&
          currentRealm !== "all" &&
          currentRegion !== "global";

        let teamHTML = "";
        run.members?.forEach((member) => {
          const specId = member.spec_id || member.specialization?.id;
          const spec = specId ? getSpecInfo(specId) : null;
          const iconUrl = spec ? getSpecIcon(spec.class, spec.spec) : null;
          const classColor = spec ? getClassColor(spec.class) : "#FFFFFF";

          const iconHTML = iconUrl && spec
            ? `<img src="${iconUrl}" alt="${spec.spec} ${spec.class}" style="width: 16px; height: 16px; border-radius: 2px; margin-right: 4px; vertical-align: middle; flex-shrink: 0;">`
            : "";

          const memberRealmSlug =
            member.realm_slug || member.profile?.realm?.slug;
          let crossRealmIndicator = "";
          if (
            isIndividualRealmView &&
            memberRealmSlug &&
            memberRealmSlug !== currentRealm
          ) {
            crossRealmIndicator =
              '<span style="color: #ff6b6b; font-weight: bold; margin-left: 2px;">*</span>';
          }

          const memberRegion = member.region || "us";
          const profileUrl = buildPlayerProfileURL(memberRegion, memberRealmSlug, member.name);

          teamHTML += `<span style="display: inline-flex; align-items: center; margin-right: 8px; gap: 4px;">
            ${iconHTML}
            <a href="${profileUrl}" style="color: ${classColor}; font-weight: 600; font-size: 0.9em; text-decoration: none;">
              ${member.name}${crossRealmIndicator}
            </a>
          </span>`;
        });

        const row = document.createElement("div");
        row.className = "leaderboard-table-row";
        row.dataset.runId = run.id;

        row.innerHTML = `
          <div class="leaderboard-cell leaderboard-cell--rank">#${rank}</div>
          <div class="leaderboard-cell leaderboard-cell--time">${duration}</div>
          <div class="leaderboard-cell leaderboard-cell--content">${teamHTML}</div>
          <div class="leaderboard-cell leaderboard-cell--meta">${timestamp}</div>
        `;

        rowsContainer?.appendChild(row);
      });
    }


    updatePagination(pagination) {
      const paginationContainer = this.container.querySelector(
        ".pagination-container",
      );

      if (!paginationContainer) {
        console.warn("‚ö†Ô∏è Dungeon leaderboard pagination container not found");
        return;
      }

      if (!pagination || pagination.totalPages <= 1) {
        console.log("üôà Hiding dungeon pagination - no data or single page");
        paginationContainer.style.display = "none";
        return;
      }

      console.log("‚úÖ Showing dungeon pagination container:", {
        currentPage: pagination.currentPage,
        totalPages: pagination.totalPages,
        totalRuns: pagination.totalRuns,
      });

      // show pagination container
      paginationContainer.style.display = "flex";

      const prevBtn = this.container.querySelector("#prev-page");
      const nextBtn = this.container.querySelector("#next-page");
      const pageInfo = this.container.querySelector(".page-info");
      const paginationInfo = this.container.querySelector(
        ".pagination-info span",
      );

      if (prevBtn) {
        prevBtn.disabled = !pagination.hasPrevPage;
        console.log("‚¨ÖÔ∏è Dungeon prev button updated:", {
          disabled: !pagination.hasPrevPage,
        });
      }
      if (nextBtn) {
        nextBtn.disabled = !pagination.hasNextPage;
        console.log("‚û°Ô∏è Dungeon next button updated:", {
          disabled: !pagination.hasNextPage,
        });
      }

      if (pageInfo) {
        pageInfo.textContent = `Page ${pagination.currentPage} of ${pagination.totalPages}`;
      }

      if (paginationInfo) {
        paginationInfo.textContent = `Showing page ${pagination.currentPage} of ${pagination.totalPages} (${pagination.totalRuns} total runs)`;
      }
    }

    updateURL() {
      // update url with current page
      const url = new URL(window.location.href);
      if (this.currentPage > 1) {
        url.searchParams.set("page", this.currentPage.toString());
      } else {
        url.searchParams.delete("page");
      }
      window.history.pushState({}, "", url.toString());
    }

    showLoading() {
      const loading = this.container.querySelector(
        "#loading-container",
      );
      const content = this.container.querySelector("#leaderboard-content");
      const error = this.container.querySelector("#error-container");

      if (loading) loading.style.display = "block";
      if (content) content.style.display = "none";
      if (error) error.style.display = "none";
    }

    hideLoading() {
      const loading = this.container.querySelector("#loading-container");
      const content = this.container.querySelector("#leaderboard-content");

      if (loading) loading.style.display = "none";
      if (content) content.style.display = "block";
    }

    showError(error) {
      const errorContainer = this.container.querySelector("#error-container");
      const errorMessage = errorContainer.querySelector(".loading-message");
      const loading = this.container.querySelector("#loading-container");
      const content = this.container.querySelector("#leaderboard-content");

      if (errorMessage) errorMessage.textContent = `Error: ${error.message}`;
      if (errorContainer) errorContainer.style.display = "block";
      if (loading) loading.style.display = "none";
      if (content) content.style.display = "none";
    }
  }

  // initialize the leaderboard table
-->

<style>
  .leaderboard-container {
    overflow: hidden;
    margin-top: 20px;
  }

  #leaderboard-rows {
    display: table;
    width: 100%;
  }

  .empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--text-muted);
    background-color: var(--bg-secondary);
    border-radius: 8px;
    border: 1px solid var(--border-color);
  }

  .empty-state p {
    margin: 8px 0;
  }

  .pagination-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 20px;
    padding: 15px;
    background-color: var(--bg-secondary);
    border-radius: 6px;
  }

  .pagination-info {
    color: var(--text-secondary);
    font-size: 0.9em;
  }

  .pagination-buttons {
    display: flex;
    align-items: center;
    gap: 15px;
  }

  .pagination-btn {
    padding: 8px 16px;
    background-color: var(--highlight-color);
    color: #000;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s ease;
  }

  .pagination-btn:hover:not(:disabled) {
    background-color: #e6d55a;
    transform: translateY(-1px);
  }

  .pagination-btn:disabled {
    background-color: #666;
    color: #999;
    cursor: not-allowed;
    transform: none;
  }

  .page-info {
    color: var(--text-primary);
    font-weight: 600;
    min-width: 100px;
    text-align: center;
  }

  .cross-realm-note {
    margin-top: 15px;
    padding: 10px;
    background-color: rgba(255, 107, 107, 0.1);
    border-left: 3px solid #ff6b6b;
    border-radius: 4px;
  }

  .cross-realm-note p {
    margin: 0;
    font-size: 0.85em;
    color: var(--text-secondary);
  }

  .warning-icon {
    color: #ff6b6b;
    font-weight: bold;
  }

  @media (max-width: 768px) {
    .pagination-container {
      flex-direction: column;
      gap: 15px;
      text-align: center;
    }
  }
</style>

<style is:global>
  #leaderboard-rows .leaderboard-row {
    display: table-row !important;
    border-bottom: 1px solid #4a4a4a !important;
    background-color: #32302f;
    transition: background-color 0.2s ease;
  }

  #leaderboard-rows .leaderboard-row:hover {
    background-color: rgba(255, 215, 0, 0.05);
  }
</style>
